# 5주차: 컴퓨팅 사고의 4대 원리 II - 추상화와 알고리즘

## 개요

### 지난 주 복습: 분해와 패턴 인식의 힘

지난 4주차에서 우리는 컴퓨팅 사고의 첫 두 가지 원리를 마스터했습니다. **분해(Decomposition)**를 통해 "온라인 쇼핑몰 만들기"같은 거대한 문제를 "상품 목록 표시", "장바구니 기능", "결제 처리"같은 관리 가능한 조각들로 나누는 법을 배웠습니다. 또한 **패턴 인식(Pattern Recognition)**을 통해 "파일 읽기"와 "파일 쓰기"가 비슷한 패턴을 가진다는 것을 발견하고, 한 번 해결한 문제를 다른 상황에 응용하는 법도 익혔습니다.

특히 기억나는 실습이 있을 것입니다. 아침 준비 루틴을 단계별로 분해하고, 가계부 데이터에서 지출 패턴을 찾아낸 것 말이죠. 그리고 이것을 GitHub Copilot에게 어떻게 전달하는지도 연습했습니다.

### 이번 주: 나머지 두 원리 완성하기

지난 주차에서 우리는 컴퓨팅 사고의 첫 두 가지 원리인 분해와 패턴 인식을 배웠습니다. 큰 문제를 작은 조각으로 나누고, 그 속에서 반복되는 규칙을 찾아내는 방법을 익혔죠. 이번 주에는 나머지 두 가지 원리인 **추상화**와 **알고리즘적 사고**를 함께 살펴보겠습니다.

추상화는 복잡한 상황에서 핵심만 남기고 불필요한 세부사항을 걷어내는 사고 방식입니다. 마치 지도가 실제 지형의 모든 디테일을 담지 않고 필요한 정보만 보여주는 것처럼, 추상화는 문제의 본질에 집중할 수 있게 해줍니다.

알고리즘적 사고는 문제를 해결하기 위한 명확한 단계를 설계하는 능력입니다. 요리 레시피처럼 "무엇을 먼저 하고, 다음엔 무엇을 할지"를 순서대로 정리하는 것이죠. 이 두 가지 원리를 익히면, 여러분은 복잡한 문제도 명확하고 단순하게 해결할 수 있게 됩니다.

이번 주차가 끝나면 여러분은:
- 추상화를 통해 문제의 핵심을 파악하고 불필요한 정보를 제거할 수 있습니다
- 알고리즘적 사고로 단계별 해결 방법을 설계할 수 있습니다
- 4대 원리(분해, 패턴 인식, 추상화, 알고리즘적 사고)를 통합하여 실제 문제에 적용할 수 있습니다
- GitHub Copilot에게 명확하고 효과적인 지시를 내릴 수 있습니다

이제 함께 추상화와 알고리즘의 세계로 들어가 보겠습니다. 어렵게 느껴질 수 있지만, 여러분은 이미 일상에서 이 두 가지를 자연스럽게 사용하고 계십니다. 우리는 그것을 의식적으로 인식하고 바이브 코딩에 활용하는 방법을 배울 것입니다.

---

## 추상화(Abstraction): 핵심만 남기기

### 추상화란 무엇인가

추상화는 복잡한 현실에서 핵심적인 정보만 추출하고 불필요한 세부사항은 제거하는 사고 과정입니다. 마치 사진을 찍을 때 배경을 흐리게 하고 주인공에게만 초점을 맞추는 것처럼, 추상화는 우리가 집중해야 할 본질을 명확히 드러냅니다.

여러분이 길을 찾을 때 지도를 사용한다고 생각해보세요. 지도는 실제 세계를 그대로 옮겨놓지 않습니다. 모든 나무, 건물의 색상, 보도블록의 패턴까지 그려 넣지 않죠. 대신 도로, 건물의 위치, 랜드마크처럼 길 찾기에 필요한 정보만 담습니다. 이것이 바로 추상화입니다.

추상화가 중요한 이유는 무엇일까요? 우리의 뇌는 한 번에 처리할 수 있는 정보의 양이 제한되어 있습니다. 모든 세부사항을 다 고려하려고 하면 정작 중요한 것을 놓치기 쉽습니다. 추상화는 복잡성을 줄여서 문제의 핵심에 집중할 수 있게 해줍니다.

// 이미지로 교체되어야 함 : 실제 거리 사진과 간소화된 지도를 나란히 비교한 이미지. 왼쪽은 복잡한 거리 전경, 오른쪽은 주요 도로와 랜드마크만 표시된 깔끔한 지도
프롬프트: A side-by-side comparison showing a complex, detailed street photograph on the left with many buildings, trees, and details, and a simplified abstract map on the right showing only main roads and key landmarks in clean lines and minimal colors

바이브 코딩에서 추상화는 특히 중요합니다. AI에게 요청할 때 모든 세부사항을 다 설명하려고 하면 오히려 혼란스러울 수 있습니다. "이 버튼을 누르면 이런 색으로 변하고, 저 부분은 어떤 폰트로..." 같은 모든 디테일을 나열하기보다, "사용자가 클릭할 수 있는 확인 버튼"처럼 핵심 기능에 집중하는 것이 더 효과적입니다.

추상화는 세 가지 핵심 질문으로 시작할 수 있습니다:
- 이 문제의 본질적인 목표는 무엇인가?
- 반드시 알아야 할 정보는 무엇인가?
- 무시해도 되는 세부사항은 무엇인가?

### 일상 속 추상화 사례

추상화는 우리 일상 곳곳에 숨어 있습니다. 의식하지 못했을 뿐, 여러분은 이미 매일 추상화를 사용하고 계십니다.

**지하철 노선도**

서울 지하철 노선도를 떠올려 보세요. 실제로 지하철은 곡선으로 굽이굽이 달리지만, 노선도는 깔끔한 직선과 각도로 표현됩니다. 역 간 거리도 실제와 다릅니다. 하지만 이 "부정확한" 지도가 오히려 더 유용합니다. 왜일까요? 우리에게 필요한 정보는 "어느 역에서 갈아타야 하는가"이지, "역 사이의 정확한 거리"가 아니기 때문입니다.

**날씨 예보 아이콘**

날씨 앱을 열면 구름, 태양, 비 같은 간단한 그림을 봅니다. 실제 하늘은 훨씬 복잡하죠. 구름의 모양, 색깔, 높이가 모두 다릅니다. 하지만 우리는 "오늘 우산을 챙겨야 하나?"라는 질문에 답하기 위해 간단한 비 아이콘만 있으면 충분합니다.

**요리 레시피**

레시피는 "감자 3개"라고 적지, "지름 5cm, 무게 150g, 표면에 작은 흠집 2개 있는 감자"라고 적지 않습니다. 요리의 결과에 중요한 정보는 양이지, 감자의 세세한 외형이 아니기 때문입니다.

**명함**

명함에는 이름, 회사, 직책, 연락처만 있습니다. 그 사람의 키, 몸무게, 취미, 좋아하는 음식은 없죠. 명함의 목적은 "이 사람과 업무적으로 연락하기"이므로, 그에 필요한 정보만 남긴 것입니다.

// 이미지로 교체되어야 함 : 일상 속 추상화의 4가지 사례를 보여주는 인포그래픽 - 지하철 노선도, 날씨 아이콘, 요리 레시피 카드, 명함을 각각 작은 일러스트로 표현
프롬프트: An infographic showing four examples of abstraction in daily life: a subway map with simplified lines, weather icons (sun, cloud, rain), a recipe card with simple ingredients list, and a business card. Clean, minimal illustration style with soft colors

### 추상화의 단계와 방법

추상화는 단계적으로 이루어집니다. 복잡한 현실을 한 번에 단순화하기보다는, 여러 층위로 나누어 점진적으로 핵심에 접근하는 것이 효과적입니다.

**1단계: 목적 명확화**

가장 먼저 "왜 이 정보가 필요한가?"를 물어보세요. 같은 대상이라도 목적에 따라 중요한 정보가 달라집니다.

예를 들어, "자동차"를 생각해봅시다:
- 중고차를 사려는 사람: 연식, 주행거리, 사고 이력이 중요
- 주차장 관리자: 차량 크기, 번호판이 중요
- 자동차 디자이너: 외형, 색상, 선의 흐름이 중요
- 정비사: 엔진 종류, 부품 상태가 중요

목적이 다르면 추상화의 결과도 완전히 달라집니다.

**2단계: 핵심 요소 식별**

목적을 명확히 했다면, 그 목적을 달성하는 데 반드시 필요한 요소만 골라냅니다. 이때 도움이 되는 질문들:
- 이것이 없으면 목적을 달성할 수 없는가?
- 이것이 바뀌면 결과가 달라지는가?
- 이것을 생략해도 본질이 유지되는가?

**3단계: 불필요한 세부사항 제거**

핵심 요소를 선택했다면, 나머지는 과감히 버립니다. 이 과정에서 "혹시 나중에 필요할까?"라는 생각이 들 수 있습니다. 하지만 진정한 추상화는 용기 있는 생략입니다. 필요하다면 나중에 다시 추가할 수 있습니다.

**4단계: 계층적 추상화**

복잡한 문제는 여러 층위의 추상화가 필요합니다. 예를 들어 "온라인 쇼핑몰" 을 생각해봅시다:

```
최상위 추상화: 물건을 사고파는 곳
 ↓
중간 추상화: 상품 검색, 장바구니, 결제 기능
 ↓
세부 추상화: 상품 검색 = 검색어 입력 + 필터링 + 결과 표시
```

이렇게 단계별로 내려가면서 필요한 만큼만 세부사항을 드러냅니다.

**바이브 코딩에서의 추상화 활용**

GitHub Copilot과 대화할 때도 추상화를 활용합니다. 예를 들어:

❌ 추상화가 부족한 요청:
"빨간색 배경에 하얀 글씨로 '확인'이라고 쓰여 있고, 마우스를 올리면 약간 어두워지고, 클릭하면 테두리가 생기고, 모서리는 5픽셀로 둥글게..."

✅ 적절히 추상화된 요청:
"사용자 확인을 위한 버튼이 필요합니다. 클릭하면 입력한 정보를 저장하는 기능입니다."

두 번째 요청이 더 명확합니다. 본질(확인 버튼, 정보 저장)에 집중하고, 구체적인 스타일은 AI가 일반적인 관례에 따라 처리하도록 맡긴 것입니다. 필요하다면 나중에 "버튼 색상을 파란색으로 변경해주세요"처럼 세부사항을 조정할 수 있습니다.

추상화는 연습으로 향상됩니다. 일상에서 만나는 문제를 "이것의 본질은 무엇인가?"라는 질문으로 바라보는 습관을 들여보세요. 처음엔 어렵지만, 점점 자연스러워질 것입니다.

## 알고리즘적 사고(Algorithmic Thinking): 단계별 문제 해결

### 알고리즘이란 무엇인가

알고리즘이라는 단어를 들으면 복잡한 수학 공식이나 어려운 컴퓨터 이론이 떠오를 수 있습니다. 하지만 알고리즘의 본질은 놀라울 만큼 단순합니다. 바로 **"문제를 해결하기 위한 명확한 단계들의 순서"**입니다.

아침에 커피를 만드는 과정을 생각해보세요:
1. 커피 머신에 물을 붓는다
2. 커피 원두를 넣는다
3. 전원을 켠다
4. 커피가 내려지기를 기다린다
5. 컵에 따른다

이것이 바로 알고리즘입니다. 특정 목표(커피 만들기)를 달성하기 위해 순서대로 따라야 할 명확한 단계들이죠.

알고리즘적 사고란 이처럼 문제를 해결하기 위한 단계를 명확하고 순서대로 설계하는 능력입니다. 좋은 알고리즘은 다음 특징을 갖습니다:

**명확성**: 각 단계가 무엇을 의미하는지 모호하지 않아야 합니다. "적당히 섞는다"보다 "10번 저어준다"가 더 명확합니다.

**순서성**: 단계의 순서가 중요합니다. 커피를 만들 때 물을 붓기 전에 전원을 켜면 제대로 작동하지 않겠죠.

**완결성**: 모든 필요한 단계가 빠짐없이 포함되어야 합니다. "커피를 만든다"는 목표를 달성하는 데 필요한 모든 과정이 들어있어야 합니다.

**실행 가능성**: 각 단계가 실제로 실행 가능해야 합니다. "마법을 부린다"는 실행할 수 없는 단계입니다.

알고리즘적 사고는 컴퓨터만을 위한 것이 아닙니다. 우리는 매일 수없이 많은 알고리즘을 사용합니다. 출근 준비, 요리, 청소, 심지어 친구에게 길 안내를 할 때도 알고리즘적으로 생각합니다.

// 이미지로 교체되어야 함 : 커피 만들기 과정을 순서도(flowchart)로 표현한 이미지. 각 단계가 박스로 표시되고 화살표로 연결됨. 간단하고 직관적인 디자인
프롬프트: A simple flowchart showing coffee making process with boxes connected by arrows. Steps include: add water, add coffee beans, turn on machine, wait, pour into cup. Clean, minimalist design with warm coffee-themed colors

### 일상 속 알고리즘 사례

알고리즘은 우리 일상 곳곳에 자연스럽게 녹아 있습니다. 의식하지 못했을 뿐, 여러분은 이미 알고리즘의 전문가입니다.

**아침 준비 루틴**

출근 전 아침 준비를 떠올려 보세요. 대부분의 사람은 자신만의 순서를 가지고 있습니다:
1. 알람이 울리면 일어난다
2. 세수를 한다
3. 옷을 입는다
4. 아침을 먹는다
5. 가방을 챙긴다
6. 집을 나선다

이 순서를 바꾸면 어떻게 될까요? 가방을 먼저 챙기고 나중에 세수를 하면 번거롭겠죠. 옷을 입기 전에 아침을 먹으면... 상상만 해도 불편합니다. 이 순서는 우연이 아니라, 효율성을 고려한 여러분만의 알고리즘입니다.

**길 찾기**

친구에게 집 찾아오는 방법을 알려줄 때:
1. 2호선 강남역에서 내린다
2. 3번 출구로 나온다
3. 직진해서 두 번째 신호등까지 간다
4. 오른쪽으로 돈다
5. 100미터 직진하면 왼쪽에 파란색 건물이 보인다

이것도 완벽한 알고리즘입니다. 단계별로 따라하면 목적지에 도착할 수 있습니다.

**요리 레시피**

파스타 레시피를 보면:
1. 물 2리터를 끓인다
2. 소금 1스푼을 넣는다
3. 면 100g을 넣는다
4. 7분간 삶는다
5. 체에 받쳐 물을 뺀다
6. 소스와 섞는다

레시피는 요리라는 목표를 달성하기 위한 알고리즘입니다. 처음 만드는 요리도 레시피를 따라하면 성공할 수 있는 이유는, 알고리즘이 명확하고 완결되어 있기 때문입니다.

**가전제품 사용 설명서**

세탁기 사용법:
1. 세탁물을 넣는다
2. 세제를 투입구에 넣는다
3. 원하는 코스를 선택한다
4. 시작 버튼을 누른다
5. 세탁이 끝나면 빨래를 꺼낸다

// 이미지로 교체되어야 함 : 일상 속 알고리즘의 4가지 예시를 아이콘과 간단한 단계로 보여주는 인포그래픽 - 아침 루틴, 길 찾기, 요리 레시피, 세탁기 사용법
프롬프트: An infographic showing four daily life algorithms: morning routine with alarm clock icon, navigation with map icon, cooking recipe with pot icon, and washing machine with appliance icon. Each shows 3-4 simple steps. Clean, friendly illustration style

### 효과적인 알고리즘 설계 방법

좋은 알고리즘을 설계하는 것은 기술이자 예술입니다. 다음 원칙들을 따르면 누구나 효과적인 알고리즘을 만들 수 있습니다.

**1. 최종 목표를 명확히 하기**

알고리즘을 설계하기 전에 "무엇을 달성하고 싶은가?"를 명확히 해야 합니다. 목표가 모호하면 알고리즘도 모호해집니다.

예시:
- 모호한 목표: "집을 깨끗하게 한다"
- 명확한 목표: "거실 바닥의 먼지를 제거한다"

명확한 목표는 필요한 단계를 선택하는 기준이 됩니다.

**2. 시작점과 끝점 정하기**

알고리즘은 명확한 시작과 끝이 있어야 합니다.

시작 조건: "어떤 상태에서 시작하는가?"
- 예: 깨끗한 냄비, 신선한 재료가 있는 상태

끝 조건: "어떤 상태가 되면 완료인가?"
- 예: 파스타가 익고 소스와 잘 섞인 상태

**3. 단계를 작고 구체적으로 나누기**

각 단계는 하나의 명확한 행동이어야 합니다. "준비한다"처럼 큰 단계는 더 작게 나눕니다.

❌ 큰 단계: "요리 준비를 한다"
✅ 작은 단계:
   1. 재료를 꺼낸다
   2. 채소를 씻는다
   3. 필요한 크기로 자른다

**4. 순서의 논리 확인하기**

각 단계가 이전 단계의 결과를 바탕으로 하는지 확인합니다. A를 하지 않고는 B를 할 수 없다면, A가 B보다 앞에 와야 합니다.

예: 요리할 때
- "불을 켠다" → "팬을 올린다" → "재료를 넣는다"
- 순서를 바꾸면 비효율적이거나 위험할 수 있습니다

**5. 예외 상황 고려하기**

모든 상황이 계획대로 되지는 않습니다. 예외 상황에 대한 대응도 알고리즘에 포함시킵니다.

예: 온라인 주문 알고리즘
1. 상품을 장바구니에 담는다
2. 결제 정보를 입력한다
3. **만약** 재고가 없으면:
   - 대체 상품을 추천한다
   - 또는 재입고 알림을 신청한다
4. 결제를 진행한다

**6. 테스트하고 개선하기**

설계한 알고리즘을 실제로 따라해보세요. 빠진 단계가 있는지, 순서가 어색한 부분은 없는지 확인합니다.

예: 친구에게 설명한 길 안내를 직접 따라가 보면, "아, 편의점을 지나서 돌아야 하는데 깜빡했네"처럼 빠진 단계를 발견할 수 있습니다.

**바이브 코딩에서의 알고리즘적 사고**

GitHub Copilot과 협업할 때도 알고리즘적 사고가 중요합니다. AI에게 "웹사이트를 만들어줘"라고 하는 것보다, 단계별로 요청하는 것이 훨씬 효과적입니다.

❌ 모호한 요청:
"사용자가 정보를 입력하고 저장할 수 있는 페이지 만들어줘"

✅ 알고리즘적 요청:
"다음 단계로 작동하는 페이지가 필요합니다:
1. 사용자가 이름과 이메일을 입력할 수 있는 양식을 보여줌
2. 입력 내용이 올바른지 확인함 (이메일 형식 체크)
3. '저장' 버튼을 누르면 입력한 정보를 저장함
4. 저장 성공 시 확인 메시지를 보여줌"

두 번째 요청은 AI가 정확히 무엇을 만들어야 하는지 이해하기 쉽습니다. 각 단계가 명확하고 순서가 논리적이기 때문입니다.

알고리즘적 사고는 연습으로 발전합니다. 일상에서 하는 일들을 의식적으로 단계별로 나누어 생각해보세요. "내가 지금 무엇을 하고 있지? 다음엔 뭘 해야 하지?"라고 자문하는 습관이 알고리즘적 사고를 키웁니다.

## 4대 원리의 통합적 적용

이제 컴퓨팅 사고의 4대 원리를 모두 배웠습니다. 분해, 패턴 인식, 추상화, 알고리즘적 사고. 각각을 따로 살펴보면 단순해 보이지만, 진짜 힘은 이 네 가지를 함께 사용할 때 발휘됩니다. 마치 요리할 때 재료 하나하나는 평범하지만, 적절히 조합하면 훌륭한 요리가 되는 것처럼요.

### 분해와 패턴 인식 복습

잠깐 지난 주에 배운 내용을 떠올려봅시다.

**분해**는 큰 문제를 작고 다루기 쉬운 조각으로 나누는 것입니다. "집 청소"를 "거실 청소, 부엌 청소, 화장실 청소"로 나누는 것처럼요. 복잡해 보이는 문제도 작게 나누면 각각은 그리 어렵지 않습니다.

**패턴 인식**은 반복되는 규칙이나 유사한 구조를 찾아내는 것입니다. 매주 월요일마다 회의가 있다는 패턴을 발견하면, 월요일 아침 일정을 효율적으로 계획할 수 있습니다.

이 두 가지는 문제를 이해하고 분석하는 단계입니다. 문제의 전체 지형을 파악하고, 효율적으로 접근할 방법을 찾는 것이죠.

### 추상화와 알고리즘의 연결

오늘 배운 **추상화**와 **알고리즘적 사고**는 문제를 해결하는 단계입니다.

**추상화**는 핵심만 남기고 불필요한 것을 제거합니다. 문제의 본질에 집중할 수 있게 해주죠. 지도가 실제 세계의 모든 디테일을 담지 않고 필요한 정보만 보여주듯이요.

**알고리즘적 사고**는 해결 방법을 명확한 단계로 정리합니다. "이것을 하고, 그 다음엔 저것을 하고"처럼 순서대로 정리하는 것입니다.

이 두 가지는 밀접하게 연결되어 있습니다. 추상화로 문제의 핵심을 파악한 후, 알고리즘으로 해결 단계를 설계합니다. 추상화가 "무엇에 집중할까?"를 정한다면, 알고리즘은 "어떤 순서로 할까?"를 정합니다.

### 4대 원리 통합 사례

이론만으로는 와닿지 않을 수 있으니, 실제 사례를 통해 4대 원리가 어떻게 함께 작동하는지 봅시다.

**사례 1: 여행 계획 세우기**

여름휴가로 제주도 3박 4일 여행을 계획한다고 가정해봅시다.

**1단계: 분해**
큰 문제 "제주도 여행"을 작은 부분으로 나눕니다:
- 교통편 예약
- 숙소 예약
- 관광지 선정
- 식당 정보 수집
- 짐 준비

**2단계: 패턴 인식**
이전 여행 경험에서 패턴을 찾습니다:
- 항상 첫날은 이동으로 피곤하니 가벼운 일정이 좋았다
- 맛집은 점심보다 저녁 시간에 줄이 길었다
- 날씨가 좋은 날 야외 활동을 했을 때 만족도가 높았다

**3단계: 추상화**
여행의 핵심 목표를 정리합니다:
- 불필요한 정보 제거: 모든 관광지를 다 가려고 하지 않음
- 핵심 목표: 휴식 + 주요 명소 2-3곳 + 맛있는 음식
- 세부사항(옷 색깔, 카메라 설정 등)보다 전체 흐름에 집중

**4단계: 알고리즘적 사고**
일정을 단계별로 정리합니다:
1. 출발 2개월 전: 항공권과 숙소 예약
2. 출발 1개월 전: 가고 싶은 장소 3곳 선정
3. 출발 2주 전: 날씨 예보 확인 후 일정 조정
4. 출발 1주 전: 맛집 예약, 렌터카 예약
5. 출발 전날: 짐 꾸리기, 체크리스트 확인
6. 여행 중: 하루 2개 이상의 활동은 하지 않기(여유 유지)

// 이미지로 교체되어야 함 : 여행 계획에 4대 원리를 적용하는 과정을 보여주는 다이어그램. 분해→패턴인식→추상화→알고리즘 순서로 각 단계의 핵심 내용이 간단히 표시됨
프롬프트: A diagram showing how four computational thinking principles are applied to travel planning. Four connected boxes in a flow: Decomposition (breaking down trip into parts), Pattern Recognition (learning from past trips), Abstraction (focusing on core goals), and Algorithmic Thinking (step-by-step schedule). Clean, infographic style

**사례 2: 온라인 강의 수강하기**

새로운 기술을 배우기 위해 온라인 강의를 듣는다고 해봅시다.

**1단계: 분해**
"강의 수강"을 나눕니다:
- 강의 선택
- 학습 시간 확보
- 실습 따라하기
- 복습하기
- 이해 안 되는 부분 해결하기

**2단계: 패턴 인식**
효과적인 학습 패턴을 찾습니다:
- 아침 시간에 집중력이 가장 좋다
- 30분 학습 후 5분 휴식이 효율적이다
- 실습을 직접 해봐야 이해가 잘 된다
- 같은 내용을 다음 날 다시 보면 기억에 오래 남는다

**3단계: 추상화**
학습의 핵심 목표를 정합니다:
- 목표: 배운 내용을 실제로 활용할 수 있게 되기
- 핵심: 개념 이해 + 실습 경험
- 불필요: 강의의 모든 세부사항을 외우려 하지 않음
- 중요: 전체 흐름과 핵심 원리 파악

**4단계: 알고리즘적 사고**
학습 과정을 단계별로 설계합니다:
1. 강의 시작 전: 오늘 배울 내용 목차 훑어보기
2. 강의 듣기: 메모하며 수강 (30분 단위)
3. 즉시 실습: 강의 내용 직접 따라하기
4. 이해 점검: 스스로 설명해보기
5. 다음 날 아침: 전날 내용 5분 복습
6. 막히는 부분: 관련 자료 찾아보거나 질문하기
7. 주말: 이번 주 배운 내용으로 작은 프로젝트 만들어보기

**사례 3: 바이브 코딩으로 간단한 웹페이지 만들기**

이제 바이브 코딩에 적용해봅시다. "개인 소개 웹페이지를 만들고 싶다"는 요청을 GitHub Copilot에게 어떻게 전달할까요?

**1단계: 분해**
웹페이지를 구성 요소로 나눕니다:
- 상단 영역(이름, 직업)
- 소개 글 영역
- 프로필 사진
- 연락처 정보
- 페이지 디자인

**2단계: 패턴 인식**
좋은 소개 페이지의 공통 패턴을 떠올립니다:
- 대부분 상단에 이름이 크게 표시됨
- 사진은 왼쪽이나 중앙에 배치됨
- 연락처는 보통 하단에 위치함
- 깔끔하고 읽기 쉬운 구조

**3단계: 추상화**
핵심 목적에 집중합니다:
- 목표: 나를 소개하고 연락 받을 수 있게 하기
- 핵심 정보: 이름, 직업, 간단한 소개, 이메일
- 불필요: 복잡한 애니메이션, 화려한 효과
- 중요: 깔끔한 디자인, 읽기 쉬운 글

**4단계: 알고리즘적 사고**
만드는 순서를 정리합니다:
1. 기본 구조 만들기(제목, 소개, 연락처 영역)
2. 내용 채우기(실제 텍스트 입력)
3. 사진 추가하기
4. 디자인 다듬기(색상, 간격 조정)
5. 모바일에서도 잘 보이는지 확인

이제 GitHub Copilot에게 요청할 준비가 되었습니다. 4대 원리를 거쳐 정리된 생각은 명확하고 구체적입니다.

### 4대 원리를 통합하는 사고 흐름

실제로 문제를 해결할 때, 4대 원리는 순서대로 한 번씩만 사용하는 것이 아닙니다. 오히려 순환하며 반복적으로 사용됩니다:

```
문제 발생
   ↓
분해: 문제를 작게 나눔
   ↓
패턴 인식: 유사한 경험 떠올림
   ↓
추상화: 핵심 목표 파악
   ↓
알고리즘: 해결 단계 설계
   ↓
실행
   ↓
결과 확인
   ↓
필요시 다시 분해부터 시작 (개선)
```

이 순환 과정을 통해 점점 더 나은 해결책을 찾아갑니다. 완벽한 해답을 처음부터 찾으려 하지 않아도 됩니다. 4대 원리를 반복 적용하며 점진적으로 개선하면 됩니다.

4대 원리는 독립적으로도 유용하지만, 함께 사용할 때 진정한 힘을 발휘합니다. 마치 자전거를 탈 때 페달, 핸들, 브레이크를 따로따로 쓰는 것이 아니라 함께 조화롭게 사용하는 것처럼요. 처음엔 의식적으로 "지금은 분해 단계, 이제 패턴 인식"이라고 생각하겠지만, 연습하다 보면 자연스럽게 통합적으로 사용하게 될 것입니다.

## 실습: GitHub Copilot에게 효과적으로 지시하기

이제 배운 내용을 실제로 적용해볼 시간입니다. 이번 실습에서는 추상화와 알고리즘적 사고, 그리고 4대 원리를 통합하여 GitHub Copilot에게 명확한 지시를 내리는 방법을 연습하겠습니다.

실습을 시작하기 전에 기억하세요: 코드를 직접 작성하지 않아도 됩니다. GitHub Copilot과의 대화에 집중하세요. 여러분의 역할은 **무엇을 만들지 생각하고**, **명확하게 요청하고**, **결과를 확인하는 것**입니다.

### 추상화를 활용한 프롬프트 작성

추상화의 핵심은 불필요한 세부사항을 제거하고 본질에 집중하는 것입니다. GitHub Copilot에게 요청할 때도 마찬가지입니다.

**실습 1: 할 일 목록 만들기**

상황: 일상의 할 일을 관리할 수 있는 간단한 도구가 필요합니다.

**잘못된 접근 (추상화 부족)**
"빨간색 배경에 하얀 글씨로 할 일을 보여주고, 체크박스는 파란색으로, 완료된 항목은 회색으로 표시하고, 추가 버튼은 오른쪽 아래에 둥근 모양으로..."

이 요청은 세부사항에 너무 집중되어 있습니다. 본질적인 목표가 무엇인지 불분명합니다.

**올바른 접근 (추상화 적용)**

먼저 핵심 목표를 생각해봅시다:
- 목표: 할 일을 추가하고, 완료 표시를 하고, 목록을 볼 수 있어야 함
- 핵심 기능: 항목 추가, 완료 체크, 목록 표시
- 불필요: 구체적인 색상, 위치, 모양 (나중에 조정 가능)

**GitHub Copilot에게 전달할 프롬프트:**

```
할 일 목록 관리 도구를 만들고 싶습니다.

필요한 기능:
1. 새로운 할 일을 추가할 수 있어야 합니다
2. 각 항목을 완료 표시할 수 있어야 합니다
3. 모든 할 일 목록을 볼 수 있어야 합니다

이 세 가지 기본 기능만 먼저 구현해주세요.
```

**실습해보기:**

1. GitHub Copilot을 엽니다
2. 위의 프롬프트를 입력합니다
3. 생성된 결과를 확인합니다
4. 필요하다면 추가로 요청합니다: "완료된 항목을 다른 색으로 표시해주세요"

**핵심 포인트:**
- 처음부터 모든 세부사항을 지정하지 않았습니다
- 핵심 기능 3가지에만 집중했습니다
- 나중에 필요한 부분만 추가로 요청할 수 있습니다

**실습 2: 간단한 계산기**

상황: 기본적인 사칙연산을 할 수 있는 계산기가 필요합니다.

**4대 원리 적용하여 생각 정리:**

**분해:** 계산기 = 숫자 입력 + 연산 선택 + 결과 표시

**패턴 인식:** 일반적인 계산기는 모두 비슷한 구조를 가짐

**추상화:** 
- 핵심: 두 숫자와 연산자를 받아 결과를 보여줌
- 불필요: 복잡한 과학 계산, 화려한 디자인

**알고리즘:**
1. 첫 번째 숫자 입력받기
2. 연산자 선택하기
3. 두 번째 숫자 입력받기
4. 계산하기
5. 결과 보여주기

**GitHub Copilot에게 전달할 프롬프트:**

```
간단한 계산기를 만들고 싶습니다.

필요한 기능:
1. 두 개의 숫자를 입력받습니다
2. 연산 종류를 선택합니다 (더하기, 빼기, 곱하기, 나누기)
3. 계산 결과를 보여줍니다

웹 페이지 형태로 만들어주세요.
```

**실습해보기:**

1. GitHub Copilot에게 위 프롬프트를 전달합니다
2. 생성된 계산기를 확인합니다
3. 실제로 작동하는지 테스트해봅니다
4. 개선이 필요하면 추가 요청: "0으로 나눌 때 오류 메시지를 보여주세요"

// 이미지로 교체되어야 함 : 추상화 프로세스를 보여주는 다이어그램. 왼쪽에 복잡한 요구사항들이 많이 적혀있고, 가운데 '추상화' 필터를 거쳐, 오른쪽에 3-4개의 핵심 기능만 남은 모습
프롬프트: A diagram showing abstraction process. Left side shows many detailed requirements in a messy cloud, middle shows an 'Abstraction' filter funnel, right side shows 3-4 clean, essential features. Simple, clear visual flow

### 알고리즘적 사고를 담은 요청

알고리즘적 사고는 단계별 순서를 명확히 하는 것입니다. GitHub Copilot에게 요청할 때도 "무엇을 어떤 순서로 하는지" 명확히 전달하면 더 정확한 결과를 얻을 수 있습니다.

**실습 3: 간단한 퀴즈 게임**

상황: 사용자에게 질문을 하나씩 내고, 정답을 맞추면 점수를 주는 퀴즈 게임을 만들고 싶습니다.

**알고리즘적으로 생각하기:**

1. 시작: 퀴즈 시작 버튼을 보여줌
2. 질문 보여주기: 첫 번째 질문을 화면에 표시
3. 답변 받기: 사용자가 답을 선택할 수 있게 함
4. 정답 확인: 선택한 답이 맞는지 확인
5. 피드백: 맞으면 "정답!", 틀리면 "오답" 표시
6. 점수 업데이트: 정답이면 점수 증가
7. 다음 질문으로: 아직 질문이 남았으면 2단계로, 끝났으면 8단계로
8. 결과 표시: 최종 점수를 보여줌

**GitHub Copilot에게 전달할 프롬프트:**

```
간단한 퀴즈 게임을 만들고 싶습니다.

동작 순서:
1. 시작 버튼을 누르면 게임이 시작됩니다
2. 질문과 4개의 선택지를 보여줍니다
3. 사용자가 하나를 선택하면 정답인지 확인합니다
4. 정답이면 "맞았습니다!"와 함께 점수가 1점 올라갑니다
5. 오답이면 "틀렸습니다"라고 표시합니다
6. "다음 문제" 버튼을 누르면 다음 질문으로 넘어갑니다
7. 모든 문제를 풀면 총 점수를 보여줍니다

질문은 3개만 준비해주세요 (예: 간단한 상식 문제).
```

**실습해보기:**

1. GitHub Copilot에게 위 프롬프트를 전달합니다
2. 생성된 퀴즈 게임을 실행해봅니다
3. 각 단계가 의도한 대로 작동하는지 확인합니다
4. 개선 사항이 있다면 요청합니다: "점수를 화면 상단에 항상 표시해주세요"

**핵심 포인트:**
- 프로그램이 작동하는 순서를 번호로 명확히 했습니다
- 각 단계에서 무슨 일이 일어나는지 구체적으로 설명했습니다
- 조건 분기(정답/오답)도 명시했습니다

**실습 4: 타이머**

상황: 공부할 때 사용할 간단한 타이머가 필요합니다.

**알고리즘 설계:**

1. 사용자가 시간을 입력 (분 단위)
2. "시작" 버튼을 누름
3. 매초마다 남은 시간 표시 업데이트
4. 남은 시간이 0이 되면
5. 알림 소리 또는 메시지 표시
6. "다시 시작" 옵션 제공

**GitHub Copilot에게 전달할 프롬프트:**

```
공부용 타이머를 만들고 싶습니다.

작동 방식:
1. 사용자가 원하는 시간(분)을 입력합니다
2. "시작" 버튼을 클릭하면 카운트다운이 시작됩니다
3. 남은 시간을 "MM:SS" 형식으로 화면에 보여줍니다
4. 매초마다 자동으로 업데이트됩니다
5. 시간이 0이 되면 "시간 종료!" 메시지를 표시합니다
6. "다시 시작" 버튼을 제공합니다

간단하고 깔끔한 디자인으로 만들어주세요.
```

**실습해보기:**

1. 프롬프트를 GitHub Copilot에게 전달합니다
2. 타이머를 실행하고 실제로 작동하는지 확인합니다
3. 1분으로 설정하고 제대로 카운트다운이 되는지 봅니다

// 이미지로 교체되어야 함 : 알고리즘을 시각화한 순서도. 퀴즈 게임의 흐름을 화살표로 연결된 박스들로 표현. 시작→질문 표시→답변 받기→정답 확인→피드백→다음 질문 또는 종료
프롬프트: A simple flowchart showing quiz game algorithm. Boxes connected with arrows: Start → Show Question → Get Answer → Check Correct? (diamond) → if yes: Add Point, if no: Show Wrong → Next Question? (diamond) → if yes: loop back, if no: Show Final Score. Clean, easy to read design

### 4대 원리를 통합한 실습

이제 4대 원리를 모두 활용하여 조금 더 복잡한 프로젝트를 해봅시다.

**종합 실습: 간단한 가계부**

상황: 하루하루 지출을 기록하고 총액을 볼 수 있는 가계부를 만들고 싶습니다.

**1단계: 분해**

큰 문제를 작은 부분으로 나눕니다:
- 지출 항목 입력 기능
- 금액 입력 기능
- 카테고리 선택 기능 (식비, 교통비 등)
- 지출 내역 목록 표시
- 총 지출 금액 계산 및 표시

**2단계: 패턴 인식**

비슷한 앱들의 공통 패턴:
- 보통 입력 폼이 상단에 있음
- 목록은 최신 항목이 위에 표시됨
- 총액은 눈에 잘 띄게 표시됨

**3단계: 추상화**

핵심 기능에 집중:
- 반드시 필요: 항목명, 금액, 목록 표시, 총액
- 있으면 좋음: 카테고리, 날짜
- 불필요(일단): 그래프, 통계, 월별 분석

**4단계: 알고리즘**

사용자 흐름 설계:
1. 지출 항목 이름을 입력
2. 금액을 입력
3. (선택) 카테고리 선택
4. "추가" 버튼 클릭
5. 입력한 항목이 목록에 추가됨
6. 총 지출 금액이 자동으로 업데이트됨
7. 필요시 2단계부터 반복

**GitHub Copilot에게 전달할 최종 프롬프트:**

```
간단한 가계부 앱을 만들고 싶습니다.

핵심 기능:
- 지출 항목 이름과 금액을 입력할 수 있어야 합니다
- 입력한 내역을 목록으로 볼 수 있어야 합니다
- 총 지출 금액이 자동으로 계산되어 표시되어야 합니다

작동 순서:
1. 항목 이름을 입력하는 칸이 있습니다
2. 금액을 입력하는 칸이 있습니다
3. "추가" 버튼을 누르면 아래 목록에 추가됩니다
4. 목록에는 "항목명 - 금액원" 형식으로 표시됩니다
5. 화면 상단에 "총 지출: OOO원"이 항상 표시됩니다
6. 새 항목을 추가하면 총액이 자동으로 업데이트됩니다

웹 페이지 형태로 만들어주세요. 간단하고 사용하기 쉽게 부탁합니다.
```

**실습해보기:**

1. GitHub Copilot에게 위 프롬프트를 전달합니다
2. 생성된 가계부 앱을 실행합니다
3. 여러 항목을 추가하며 기능을 테스트합니다:
   - "점심" 8,000원
   - "버스" 1,250원
   - "커피" 4,500원
4. 총액이 제대로 계산되는지 확인합니다 (13,750원)
5. 추가 개선 사항을 요청합니다:
   - "각 항목을 삭제할 수 있는 버튼을 추가해주세요"
   - "카테고리를 선택할 수 있게 해주세요 (식비, 교통비, 기타)"

**반성 및 개선:**

실습을 마친 후 스스로 질문해봅시다:
- 프롬프트가 충분히 명확했나요?
- 4대 원리를 적용하는 것이 도움이 되었나요?
- 결과물이 처음 의도와 일치하나요?
- 더 개선할 부분이 있나요?

**핵심 깨달음:**

이번 실습을 통해 알 수 있듯이, 코드를 한 줄도 직접 작성하지 않았지만 여러분은 이미:
- 문제를 분석했습니다 (분해, 패턴 인식)
- 해결 방법을 설계했습니다 (추상화, 알고리즘)
- 명확한 지시를 내렸습니다 (프롬프트)
- 결과를 확인하고 개선했습니다

이것이 바로 바이브 코딩입니다. 여러분의 역할은 생각하고, 설계하고, 소통하는 것입니다. 실제 코드 작성은 GitHub Copilot이 담당합니다.

처음엔 프롬프트를 작성하는 것이 어색할 수 있습니다. "이렇게 말해도 이해할까?" 하는 의구심이 들 수도 있죠. 하지만 연습할수록 자연스러워집니다. 그리고 무엇보다, 틀려도 괜찮습니다. 결과를 보고 다시 요청하면 됩니다. 이것이 바이브 코딩의 반복적 개선 과정입니다.

## 실습 결과 요약

이번 주차에서 우리는 컴퓨팅 사고의 나머지 두 원리인 **추상화**와 **알고리즘적 사고**를 배웠습니다. 그리고 지난 주에 배운 분해, 패턴 인식과 함께 4대 원리를 통합적으로 활용하는 방법을 익혔습니다.

### 핵심 내용 정리

**추상화(Abstraction)**
- 복잡한 문제에서 핵심만 남기고 불필요한 세부사항을 제거하는 사고 방식입니다
- 지도, 날씨 아이콘, 명함처럼 우리는 이미 일상에서 추상화를 사용합니다
- 바이브 코딩에서는 "무엇을 만들지"의 본질에 집중하고, 세부적인 구현은 AI에게 맡깁니다
- 좋은 추상화는 목적을 명확히 하고, 핵심 요소만 식별하며, 불필요한 것을 과감히 제거합니다

**알고리즘적 사고(Algorithmic Thinking)**
- 문제를 해결하기 위한 명확한 단계를 순서대로 설계하는 능력입니다
- 커피 만들기, 아침 준비, 요리 레시피처럼 우리의 일상은 알고리즘으로 가득합니다
- 좋은 알고리즘은 명확하고, 순서가 논리적이며, 완결되어 있고, 실행 가능해야 합니다
- GitHub Copilot에게 단계별로 요청하면 훨씬 정확한 결과를 얻을 수 있습니다

**4대 원리의 통합**
- 분해: 큰 문제를 작은 부분으로 나눔
- 패턴 인식: 반복되는 규칙을 찾아냄
- 추상화: 핵심 목표에 집중함
- 알고리즘: 해결 단계를 순서대로 설계함

이 네 가지는 독립적이지 않고 서로 연결되어 있습니다. 실제 문제를 해결할 때는 이 원리들을 순환적으로 반복하며 점진적으로 개선해 나갑니다.

### 실습을 통해 배운 것

실습에서 여러분은 직접 코드를 작성하지 않고도:
- 할 일 목록을 만들었습니다 (추상화 연습)
- 계산기를 만들었습니다 (4대 원리 통합)
- 퀴즈 게임을 만들었습니다 (알고리즘적 사고)
- 타이머를 만들었습니다 (단계별 설계)
- 간단한 가계부를 만들었습니다 (종합 실습)

이 모든 과정에서 여러분의 역할은:
1. 무엇을 만들지 **생각**하기
2. 문제를 **분석**하고 **설계**하기
3. GitHub Copilot에게 **명확히 전달**하기
4. 결과를 **확인**하고 **개선**하기

이것이 바로 바이브 코딩의 본질입니다.

### 프롬프트 작성의 패턴

효과적인 프롬프트는 다음과 같은 구조를 따릅니다:

```
[무엇을 만들지 간단히 설명]

필요한 기능:
- [핵심 기능 1]
- [핵심 기능 2]
- [핵심 기능 3]

작동 순서:
1. [첫 번째 단계]
2. [두 번째 단계]
3. [조건이 있다면: 만약 ~ 하면 ~]
4. [마지막 단계]

[추가 요청사항이나 제약조건]
```

이 패턴은 추상화(핵심 기능)와 알고리즘(작동 순서)을 자연스럽게 포함합니다.

### 자주 하는 실수와 개선 방법

**실수 1: 너무 많은 세부사항 나열**
❌ "빨간색 배경에 18px 크기 폰트로..."
✅ "사용자가 클릭할 수 있는 버튼"

**실수 2: 목적 없이 기능만 나열**
❌ "버튼 3개, 입력창 2개, 리스트 하나"
✅ "사용자 정보를 입력받고 저장하는 양식"

**실수 3: 단계 없이 한 번에 요청**
❌ "웹사이트 만들어줘"
✅ "먼저 사용자가 이름을 입력할 수 있는 페이지부터 만들어주세요"

**실수 4: 모호한 표현**
❌ "적당히 예쁘게"
✅ "간단하고 깔끔한 디자인으로"

### 다음 단계를 위한 준비

이번 주차에서 컴퓨팅 사고의 4대 원리를 모두 배웠습니다. 하지만 이것은 시작일 뿐입니다. 다음 주차부터는:
- GitHub Copilot과 더 깊이 있는 대화를 나누는 방법을 배웁니다
- 프롬프트 엔지니어링 기술을 익힙니다
- 반복적 개선 전략을 연습합니다
- 더 복잡한 프로젝트에 도전합니다

### 연습 과제

이번 주에 배운 내용을 복습하고 싶다면:

**1. 추상화 연습**

여러분이 자주 하는 일 하나를 선택하고, 추상화를 적용해보세요.

예시: "저녁 식사 준비"
- 구체적인 모든 과정: 냉장고 열기, 재료 꺼내기, 씻기, 자르기, 팬 꺼내기, 기름 두르기, 불 켜기, 재료 넣기, 뒤집기, 간 보기, 불 끄기, 그릇 꺼내기, 담기...
- 추상화 1단계(중간 수준): 재료 준비 → 조리 → 담기
- 추상화 2단계(고수준): 식사 준비
- 목적에 따른 추상화:
  - 배달 vs 직접 요리 결정: "오늘 요리할 시간이 있나?" → 시간 가용성만 중요
  - 레시피 선택: "어떤 재료가 있나?" → 재료 종류만 중요
  - 영양 계획: "어떤 영양소가 필요한가?" → 영양 성분만 중요

여러분의 일상 활동을 선택하여 연습해보세요:
- 출근 준비
- 온라인 쇼핑
- 운동 루틴
- 청소

각 활동에서:
- 핵심 목적이 무엇인가요?
- 어떤 정보가 반드시 필요한가요?
- 어떤 세부사항은 무시해도 될까요?

**2. 알고리즘 연습**

간단한 일상 활동을 단계별로 나열해보세요. 

예시: "샌드위치 만들기"

기본 알고리즘:
1. 식빵 2장을 준비한다
2. 한 장에 재료를 올린다
3. 다른 한 장으로 덮는다

개선된 알고리즘 (조건 포함):
1. 식빵 2장을 준비한다
2. **만약** 식빵이 딱딱하면:
   - 토스터에 1분간 굽는다
3. 한 장에 버터를 바른다
4. 좋아하는 재료를 올린다 (치즈, 야채, 햄 등)
5. **만약** 치즈를 올렸다면:
   - 전자레인지에 20초간 데운다
6. 다른 한 장으로 덮는다
7. 대각선으로 반 자른다

여러분의 활동으로 연습하세요:
- 커피 내리기 (조건: 원두가 있는지 없는지)
- 출근 경로 선택 (조건: 시간대, 날씨)
- 옷 선택 (조건: 날씨, 약속 종류)

연습할 때 확인사항:
- 각 단계가 명확한가?
- 순서가 논리적인가?
- 조건 분기가 있다면 제대로 처리했는가?
- 빠진 단계는 없는가?

**3. 통합 연습**

여러분이 해결하고 싶은 작은 문제를 선택하고, 4대 원리를 모두 적용해보세요.

예시 문제: "매일 마시는 물의 양을 기록하고 싶다"

**분해:**
- 물 마신 양 입력하기
- 누적량 계산하기
- 목표량과 비교하기
- 기록 보기

**패턴 인식:**
- 보통 하루 8잔이 권장됨
- 아침, 점심, 저녁 시간대에 주로 마심
- 운동 후에 더 많이 마심
- 비슷한 앱들은 컵 아이콘을 사용함

**추상화:**
- 핵심 목적: 수분 섭취량 관리
- 필수 정보: 마신 양, 목표량, 현재 누적량
- 불필요: 물의 온도, 컵의 색깔, 정확한 시간 (시간대만 알면 됨)

**알고리즘:**
1. 하루 시작 시 목표량 설정 (기본: 2000ml)
2. 물을 마실 때마다:
   - 마신 양 입력
   - 누적량에 더하기
   - 화면에 업데이트
3. 목표량과 비교:
   - **만약** 누적량이 목표량보다 적으면:
     - "남은 목표: XXml" 표시
   - **만약** 목표량을 달성하면:
     - "목표 달성!" 메시지
4. 하루가 끝나면 기록 저장
5. 이전 기록 조회 가능

**GitHub Copilot에게 전달할 프롬프트 작성:**

```
물 섭취량을 기록하는 앱을 만들고 싶습니다.

핵심 기능:
- 마신 물의 양(ml)을 입력할 수 있어야 합니다
- 오늘 마신 총량을 보여줘야 합니다
- 하루 목표량(2000ml)과 비교해서 남은 양을 보여줘야 합니다

작동 순서:
1. 화면 상단에 "오늘의 목표: 2000ml"를 표시합니다
2. "현재 섭취량: 0ml"를 표시합니다
3. 마신 양을 입력하는 칸이 있습니다
4. "추가" 버튼을 누르면 현재 섭취량에 더해집니다
5. 목표량을 달성하면 "축하합니다! 목표 달성!"을 표시합니다
6. 목표 전이라면 "남은 목표: XXml"를 표시합니다

간단하고 사용하기 쉽게 만들어주세요.
```

여러분도 해결하고 싶은 문제로 연습해보세요:
- 독서 기록 관리
- 간단한 습관 체크리스트
- 점심 메뉴 추천기
- 영화 감상 기록

**4. 실습 복습 및 변형**

이번 주차의 실습을 다시 해보되, 조금 다르게 변형해보세요.

**할 일 목록 변형 아이디어:**
- 우선순위 기능 추가 (높음, 보통, 낮음)
- 마감일 추가
- 완료된 항목 숨기기/보기 토글
- 카테고리별로 분류 (일, 개인, 공부 등)

변형 프롬프트 예시:
```
이전에 만든 할 일 목록에 우선순위 기능을 추가하고 싶습니다.

추가 기능:
- 각 할 일에 우선순위를 선택할 수 있어야 합니다 (높음, 보통, 낮음)
- 우선순위에 따라 다른 색으로 표시해주세요 (높음: 빨강, 보통: 노랑, 낮음: 초록)
- 우선순위 순으로 정렬되어 보이면 좋겠습니다
```

**계산기 변형 아이디어:**
- 이전 계산 기록 보기
- 퍼센트 계산 추가
- 계산 기록 지우기 버튼
- 연속 계산 가능하게 (이전 결과를 다음 계산에 사용)

**퀴즈 게임 변형 아이디어:**
- 시간 제한 추가
- 힌트 기능
- 난이도 선택 (쉬움, 보통, 어려움)
- 최고 점수 기록

**가계부 변형 아이디어:**
- 수입도 기록하기
- 카테고리별 지출 비율 보기
- 예산 설정 및 초과 알림
- 날짜별로 보기

각 변형을 시도할 때:
1. 먼저 4대 원리로 생각 정리
2. 프롬프트 작성
3. GitHub Copilot에게 요청
4. 결과 확인 및 개선

**5. 추상화 레벨 연습**

같은 문제를 서로 다른 추상화 레벨로 표현해보세요.

예시: "영화 추천받기"

**레벨 1 (매우 구체적):**
"액션 영화 중에서 2020년 이후에 나온 것, 평점 8점 이상, 상영시간 2시간 이내, 한국어 자막 있는 것을 찾아서 제목, 감독, 줄거리를 보여주고, 인터넷 평점도 같이 표시해줘"

**레벨 2 (중간):**
"내 취향에 맞는 액션 영화를 추천해줘. 최근 영화면 좋겠어."

**레벨 3 (매우 추상적):**
"오늘 볼 영화 추천해줘"

각 레벨의 장단점:
- 레벨 1: 정확하지만 제약이 많고 유연성 부족
- 레벨 2: 균형 잡혀 있고 실용적
- 레벨 3: 유연하지만 예상과 다른 결과가 나올 수 있음

상황에 맞는 추상화 레벨을 선택하는 것이 중요합니다!

---

## 실습: 추상화와 알고리즘으로 프로그램 만들기

이제 여러분이 직접 추상화와 알고리즘적 사고를 활용하여 프로그램을 만들어봅시다.

### 실습 1: 추상화 연습 - 간단한 메모장

**목표:** 핵심만 남기고 불필요한 것을 제거하는 능력 키우기

**문제 상황:**
복잡한 워드프로세서가 아니라, 빠르게 생각을 적고 저장할 수 있는 간단한 메모장이 필요합니다.

**1단계: 추상화 연습**

워드프로세서에는 이런 기능들이 있습니다:
- 텍스트 입력 ✓ (필수)
- 글자 크기 조절 ✗ (불필요)
- 글자 색상 변경 ✗ (불필요)
- 저장하기 ✓ (필수)
- 불러오기 ✓ (필수)
- 맞춤법 검사 ✗ (불필요)
- 이미지 삽입 ✗ (불필요)
- 표 만들기 ✗ (불필요)

여러분이라면 무엇을 남기고 무엇을 제거하시겠어요?

**2단계: 핵심 기능만 추출**

간단한 메모장의 핵심:
1. 텍스트를 입력할 수 있다
2. 입력한 내용을 파일로 저장할 수 있다
3. 저장한 내용을 다시 불러올 수 있다

이것만 있으면 메모장의 목적은 달성됩니다!

**3단계: GitHub Copilot에게 요청**

추상화된 요구사항으로 요청해봅시다:

"간단한 메모장 프로그램을 만들어줘.

핵심 기능만:
- 여러 줄의 텍스트를 입력할 수 있어야 해
- '저장' 버튼을 누르면 파일로 저장돼
- '불러오기' 버튼으로 저장한 파일을 다시 볼 수 있어

복잡한 서식 기능은 필요 없어. 
텍스트만 입력하고 저장하고 불러오면 돼."

**4단계: 결과 확인**

프로그램을 실행해보세요:
- 간단한 메모를 작성합니다
- 저장합니다
- 프로그램을 닫았다가 다시 엽니다
- 저장한 메모를 불러옵니다

작동하나요? 그렇다면 추상화 성공입니다!

**5단계: 필요하면 조금씩 추가**

기본이 잘 작동한다면, 정말 필요한 기능만 하나씩 추가해봅시다:

"잘 작동하네! 이제 여러 개의 메모를 관리하고 싶어.
메모마다 제목을 붙이고, 제목 목록에서 선택하면 
그 메모를 불러오게 해줘."

**학습 포인트:**

✓ 처음부터 모든 기능을 넣으려고 하지 마세요
✓ 핵심만 구현해도 충분히 유용합니다
✓ 필요할 때 기능을 추가하는 것이 더 현명합니다
✓ 간단한 것이 오히려 더 자주 사용됩니다

---

### 실습 2: 알고리즘 연습 - 수 맞추기 게임

**목표:** 단계별 절차를 논리적으로 설계하는 능력 키우기

**과제:** 컴퓨터가 생각한 숫자를 맞추는 게임 만들기

**1단계: 알고리즘 설계 (종이에 적기)**

게임의 흐름을 단계별로 정리해봅시다:

```
1. [시작] 컴퓨터가 1~100 사이의 숫자를 하나 생각한다
2. [입력] 사용자에게 숫자를 물어본다
3. [비교] 
   - 만약 정답이면 → "정답입니다!" 출력하고 종료
   - 만약 입력한 숫자가 정답보다 크면 → "더 작은 수입니다"
   - 만약 입력한 숫자가 정답보다 작으면 → "더 큰 수입니다"
4. [반복] 2번으로 돌아가기
5. [종료] 정답을 맞출 때까지 반복
```

이것이 알고리즘입니다! 명확한 단계와 조건이 있죠.

**2단계: 알고리즘 개선**

더 재미있게 만들려면?

```
1. [시작] 컴퓨터가 1~100 사이의 숫자를 하나 생각한다
2. [초기화] 시도 횟수 = 0
3. [입력] 사용자에게 숫자를 물어본다
4. [카운트] 시도 횟수 = 시도 횟수 + 1
5. [비교]
   - 만약 정답이면:
     - "정답입니다! X번 만에 맞췄습니다!" 출력
     - 종료
   - 만약 입력한 숫자가 정답보다 크면:
     - "더 작은 수입니다"
     - 3번으로
   - 만약 입력한 숫자가 정답보다 작으면:
     - "더 큰 수입니다"  
     - 3번으로
6. [힌트] 만약 5번 이상 틀렸으면:
   - "힌트: 정답은 XX와 YY 사이입니다"
7. 3번으로 돌아가기
```

**3단계: GitHub Copilot에게 요청**

알고리즘을 명확히 전달해봅시다:

"숫자 맞추기 게임을 만들어줘.

게임 흐름:
1. 프로그램이 1부터 100 사이의 숫자를 하나 정해 (사용자는 모르게)
2. 사용자에게 숫자를 입력받아
3. 입력한 숫자와 정답을 비교해서:
   - 정답이면: '정답!' 메시지와 함께 종료
   - 틀리면: 더 큰 수인지 작은 수인지 힌트를 줘
4. 정답을 맞출 때까지 2-3번을 반복해
5. 정답을 맞추면 몇 번 만에 맞췄는지 알려줘

먼저 이 기본 버전을 만들어줘."

**4단계: 테스트 및 개선**

게임을 플레이해보세요:
- 여러 번 시도해보기
- 범위를 벗어난 숫자를 입력하면?
- 문자를 입력하면?

문제를 발견하면 Copilot에게 개선 요청:

"잘 작동해! 그런데 몇 가지 개선하고 싶어:
1. 1~100 범위를 벗어난 숫자를 입력하면 '1~100 사이로 입력해주세요' 메시지
2. 5번 이상 틀리면 힌트를 줘 (정답 범위를 좁혀서)
3. 게임이 끝나면 '다시 하시겠습니까?' 물어보기"

**5단계: 난이도 추가 (도전 과제)**

"이제 난이도를 선택할 수 있게 해줘:
- 쉬움: 1~50 사이
- 보통: 1~100 사이  
- 어려움: 1~1000 사이

게임 시작 전에 난이도를 선택하게 해줘."

**학습 포인트:**

✓ 알고리즘은 명확한 단계와 조건으로 이루어집니다
✓ 조건 분기(if-else)는 다양한 상황을 처리합니다
✓ 반복(loop)은 같은 작업을 여러 번 수행합니다
✓ 알고리즘을 명확히 설계하면 Copilot이 정확히 구현합니다

---

### 실습 3: 통합 실습 - 물 섭취량 추적기

**목표:** 4대 원리를 모두 활용하여 실용적인 프로그램 만들기

앞서 이론 설명에서 본 물 섭취량 추적기를 실제로 만들어봅시다. 이번에는 4대 원리를 모두 사용합니다.

**1단계: 문제 분석 (4대 원리 적용)**

**분해:**
- 목표량 설정
- 마신 양 기록
- 누적량 계산
- 진행상황 표시

**패턴 인식:**
- 일반적으로 하루 2000ml가 권장됨
- 여러 번에 걸쳐 조금씩 마심
- 목표 달성 여부를 시각적으로 보여주는 패턴

**추상화:**
- 핵심: 얼마나 마셨는지, 목표까지 얼마나 남았는지
- 불필요: 정확한 시각, 물의 온도, 컵의 종류

**알고리즘:**
```
1. 하루 목표 = 2000ml
2. 현재 섭취량 = 0ml
3. 반복:
   a. 사용자에게 마신 양 입력받기
   b. 현재 섭취량 += 마신 양
   c. 남은 양 = 목표 - 현재 섭취량
   d. 만약 남은 양 <= 0이면:
      - "목표 달성!" 표시
      아니면:
      - "남은 목표: (남은 양)ml" 표시
4. 사용자가 종료할 때까지 반복
```

**2단계: GitHub Copilot에게 요청**

```
물 섭취량을 추적하는 프로그램을 만들어줘.

기능:
1. 하루 목표: 2000ml (화면 상단에 표시)
2. 현재 섭취량: 시작할 때 0ml
3. 사용자가 마신 양(ml)을 입력하면:
   - 현재 섭취량에 더하기
   - 업데이트된 총량 보여주기
4. 목표 대비 진행상황:
   - 아직 목표 미달: "남은 목표: XXml"
   - 목표 달성: "축하합니다! 목표 달성!"
5. 계속 입력받을 수 있어야 함

간단하고 보기 쉽게 만들어줘.
```

**3단계: 테스트**

프로그램을 사용해보세요:
- 200ml 입력 → 현재: 200ml, 남은 목표: 1800ml
- 300ml 입력 → 현재: 500ml, 남은 목표: 1500ml
- 1500ml 입력 → 현재: 2000ml, 목표 달성!
- 200ml 더 입력 → 현재: 2200ml, 목표 초과!

**4단계: 개선 요청**

"잘 작동해! 몇 가지 추가하고 싶어:
1. 퍼센트로도 보여줘 (예: 75% 달성)
2. 목표를 사용자가 변경할 수 있게
3. 하루 기록을 파일로 저장
4. 지난 기록 보기"

한 번에 하나씩 추가하며 테스트하세요.

**5단계: 나만의 변형 (선택)**

이 패턴을 다른 것에도 적용해보세요:
- 걷기 목표 추적 (하루 10,000보)
- 독서 목표 추적 (월 4권)
- 저축 목표 추적 (월 50만원)

**완성 체크리스트:**
- [ ] 기본 입력/출력이 작동합니다
- [ ] 목표 대비 진행상황이 정확히 계산됩니다
- [ ] 목표 달성 시 메시지가 나타납니다
- [ ] 여러 번 입력해도 잘 작동합니다
- [ ] 직관적이고 사용하기 쉽습니다

축하합니다! 여러분은 4대 원리를 모두 활용하여 실용적인 프로그램을 만들었습니다!

**시간 가이드:**
- 4대 원리로 분석: 5분
- 기본 버전 구현: 10-15분
- 테스트 및 버그 수정: 5분
- 추가 기능 (선택): 10분

**학습 포인트:**

이 실습을 통해 여러분은:
✓ 4대 원리를 실제로 통합하여 사용하는 방법을 배웠습니다
✓ 작은 프로그램이라도 체계적 사고가 중요함을 알았습니다
✓ Copilot과 협업하여 실용적인 결과를 만들 수 있습니다
✓ 하나의 패턴을 다양한 문제에 적용할 수 있습니다
- 레벨 2: 균형잡힘, 핵심은 남기고 유연성 확보
- 레벨 3: 유연하지만 의도와 다른 결과 가능

GitHub Copilot에게 요청할 때도 상황에 맞는 추상화 레벨을 선택하세요:
- 정확히 원하는 것이 있다면: 레벨 1
- 일반적인 경우: 레벨 2 (권장)
- 탐색 단계라면: 레벨 3

여러분의 문제로 연습해보세요:
- 식당 추천
- 여행지 선택
- 책 고르기
- 운동 계획

### 마무리하며

여러분은 이제 컴퓨팅 사고의 4대 원리를 모두 이해했습니다. 처음엔 낯설었을 개념들이 점차 자연스러워지고 있을 것입니다. 

**지금까지의 여정**

1주차에 바이브 코딩이라는 새로운 세계를 만났을 때, 혹시 "나도 할 수 있을까?" 하는 의구심이 들지 않았나요? 2주차에 컴퓨팅 사고의 필요성을 배우면서 "왜 이게 중요한지"를 이해했고, 3주차에는 실제로 GitHub Copilot을 만나 첫 경험을 했습니다.

4주차와 5주차, 지난 두 주 동안 여러분은 컴퓨팅 사고의 핵심인 4대 원리를 배웠습니다:
- **분해**: 큰 문제를 작은 조각으로
- **패턴 인식**: 반복되는 규칙 발견
- **추상화**: 핵심만 남기기
- **알고리즘**: 단계별 해결 방법

이 네 가지가 처음엔 각각 독립된 개념처럼 보였겠지만, 실습을 하면서 이들이 어떻게 조화롭게 함께 작동하는지 느끼셨을 것입니다.

**여러분이 이룬 성장**

돌이켜보면 여러분은 이미 많은 것을 할 수 있게 되었습니다:
- 복잡한 문제를 체계적으로 분석할 수 있습니다
- 일상의 경험에서 패턴을 찾아낼 수 있습니다
- 문제의 본질을 파악하고 불필요한 것을 걸러낼 수 있습니다
- 해결 방법을 명확한 단계로 정리할 수 있습니다
- GitHub Copilot에게 효과적으로 지시를 내릴 수 있습니다

이 모든 것을 코드 한 줄 직접 작성하지 않고 해냈습니다. 이것이 바로 바이브 코딩의 힘입니다.

**완벽하지 않아도 괜찮습니다**

혹시 아직도 "내 프롬프트가 충분히 좋은가?" 걱정되시나요? 그럴 필요 없습니다. 바이브 코딩의 아름다움은 완벽을 추구하지 않는다는 것입니다.

프롬프트가 처음부터 완벽하지 않아도 괜찮습니다. GitHub Copilot의 결과가 기대와 조금 다르더라도 괜찮습니다. 왜냐하면:
- 대화로 개선할 수 있으니까
- 다시 요청할 수 있으니까
- 조금씩 나아가면 되니까

바이브 코딩은 완성품을 단번에 만드는 것이 아니라, 반복적으로 개선하는 과정입니다. 마치 조각가가 돌을 조금씩 깎아내며 작품을 만들듯이, 여러분도 GitHub Copilot과 대화하며 점점 원하는 결과에 가까워집니다.

**실수는 배움의 기회**

실습하면서 GitHub Copilot이 예상과 다른 결과를 준 적이 있었나요? 그것은 실패가 아니라 배움의 기회입니다.

"아, 이렇게 요청하면 이런 결과가 나오는구나"
"다음엔 이 부분을 더 명확히 해야겠네"
"이 기능은 나중에 추가하는 게 낫겠어"

이런 깨달음 하나하나가 여러분을 더 나은 바이브 코더로 만듭니다. 전문 프로그래머들도 처음부터 완벽한 코드를 작성하지 않습니다. 시도하고, 테스트하고, 수정하는 과정을 반복합니다. 여러분도 마찬가지입니다.

**일상에서의 적용**

4대 원리는 GitHub Copilot과 작업할 때만 유용한 것이 아닙니다. 여러분의 일상 곳곳에 적용할 수 있습니다:

**직장에서:**
- 프로젝트 계획을 세울 때 → 분해와 알고리즘
- 반복 업무를 효율화할 때 → 패턴 인식
- 보고서를 작성할 때 → 추상화

**개인 생활에서:**
- 목표를 달성하기 위한 계획 → 4대 원리 통합
- 의사결정을 내릴 때 → 추상화와 알고리즘
- 문제 해결할 때 → 분해와 패턴 인식

컴퓨팅 사고는 프로그래밍을 위한 것만이 아니라, 체계적으로 생각하고 효과적으로 문제를 해결하는 사고방식입니다. 이제 여러분은 그 도구를 갖추었습니다.

**다음 단계로**

다음 주부터는 새로운 단계로 나아갑니다. 6주차에는 **GitHub Copilot과 효과적으로 협업하는 방법**을 본격적으로 배웁니다.

여러분이 배울 내용:
- **프롬프트 엔지니어링**: 더 효과적인 요청 방법
- **명확한 목표 제시**: 원하는 것을 정확히 전달하기
- **충분한 컨텍스트 제공**: AI가 더 잘 이해하도록 돕기
- **단계별 개선 요청**: 점진적으로 완성도 높이기
- **AI의 강점과 한계**: 언제 의지하고 언제 조정할지

지금까지 배운 4대 원리가 탄탄한 기반이 되어줄 것입니다. 분해, 패턴 인식, 추상화, 알고리즘적 사고를 이해했기 때문에, 프롬프트를 작성할 때 자연스럽게 이 원리들을 활용하게 될 것입니다.

**격려의 말**

여기까지 오신 여러분, 정말 잘하고 계십니다. 

5주 전의 여러분과 지금의 여러분은 다릅니다. 문제를 보는 눈이 달라졌고, 해결하는 방법을 알게 되었습니다. GitHub Copilot과 소통하는 법을 배웠고, 무엇보다 "나도 할 수 있다"는 자신감을 얻었습니다.

프로그래밍 경험이 전혀 없어도, 컴퓨터와 친하지 않아도, 여러분은 이미 바이브 코딩을 하고 있습니다. 할 일 목록을 만들고, 계산기를 만들고, 퀴즈 게임을 만들었습니다. 코드를 직접 작성하지 않고 말이죠.

앞으로도 계속 이런 식입니다. 조금씩, 하지만 확실하게 성장해 나갈 것입니다. 

**이번 주의 실천**

이번 주 동안 시도해보세요:
- 하루에 한 번, 일상의 문제를 4대 원리로 분석해보기
- 연습 과제 중 하나를 골라서 실제로 GitHub Copilot과 시도해보기
- 막히는 부분이 있어도 포기하지 말고 다르게 요청해보기
- 작은 성공을 기록하고 스스로를 격려하기

완벽하게 하려고 하지 마세요. 해보는 것 자체가 중요합니다. 

**함께 가는 여정**

여러분은 혼자가 아닙니다. 이 책을 읽는 많은 사람들이 같은 여정을 걷고 있습니다. 어떤 이는 여러분보다 조금 앞서 있고, 어떤 이는 지금 막 시작했을 것입니다. 

서로 다른 속도로 배우는 것은 자연스러운 일입니다. 중요한 것은 자신의 페이스로 꾸준히 나아가는 것입니다.

다음 주에 다시 만나요. 그때는 GitHub Copilot과 더 깊이 있는 대화를 나누는 방법을 배우게 될 것입니다. 기대하셔도 좋습니다!

---

**잠깐! 다음 주차 미리보기**

다음 주에는 이런 것들을 배웁니다:

**효과적인 프롬프트의 비밀**
- "할 일 목록 만들어줘"와 "사용자가 할 일을 추가, 완료 표시, 삭제할 수 있는 목록 관리 도구를 만들어줘"의 차이
- 왜 후자가 더 나은 결과를 가져오는지
- 어떻게 프롬프트를 구조화하면 좋은지

**GitHub Copilot Agent 모드와의 대화**
- Agent가 여러 파일을 다루는 방법
- 복잡한 요청을 효과적으로 전달하기
- Agent의 응답을 이해하고 피드백하기

**반복적 개선의 기술**
- 첫 결과가 마음에 안 들 때 어떻게 개선 요청을 하는지
- "조금 더 간단하게", "색상을 바꿔줘"처럼 효과적인 수정 요청
- 언제 새로 시작하고 언제 계속 개선할지

6주차가 끝나면 여러분은 GitHub Copilot을 마치 팀원처럼 자연스럽게 활용할 수 있게 될 것입니다.

그럼 다음 주에 만나요! 잘 쉬시고, 이번 주 배운 내용을 천천히 복습해보세요. 급할 것 없습니다. 여러분의 속도로 가면 됩니다.
