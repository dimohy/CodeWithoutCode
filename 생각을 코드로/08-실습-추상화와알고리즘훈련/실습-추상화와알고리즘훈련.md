# 8주차: 실습 - 추상화와 알고리즘 훈련

## 개요

### 지난 주 복습: 분해와 패턴 인식 실습

지난주에 분해와 패턴 인식을 연습했다면, 이번 주는 컴퓨팅 사고의 나머지 두 원리인 **추상화**와 **알고리즘적 사고**를 집중적으로 훈련합니다.

지난 7주차에서 우리는 중요한 경험을 했습니다. 아침 준비 루틴을 단계별로 분해하고, 가계부 데이터에서 지출 패턴을 찾아내고, 이것을 GitHub Copilot에게 효과적으로 전달하는 연습을 했습니다. 이론으로만 알던 것을 실제로 적용해보니, 처음에는 어려웠지만 점차 자연스러워졌을 것입니다.

특히 분해를 통해 큰 문제를 작은 조각들로 나누니 Agent가 훨씬 정확하게 이해하고, 패턴을 참조하니 "이전에 만든 파일 읽기 코드와 비슷하게"라고 요청하면 일관된 스타일로 코드를 생성해준다는 것도 확인했습니다.

### 이번 주: 4대 원리 완성 단계

지난주에 분해와 패턴 인식을 연습했다면, 이번 주는 컴퓨팅 사고의 나머지 두 원리인 **추상화**와 **알고리즘적 사고**를 집중적으로 훈련합니다. 그리고 무엇보다 중요한 것은, 이제 4대 원리를 모두 배웠으니 이들을 함께 활용하는 방법을 익히는 것입니다.

추상화는 복잡한 것에서 핵심만 남기고 불필요한 디테일을 걷어내는 기술입니다. 마치 지도가 실제 세계의 모든 세부사항을 담지 않고 필요한 정보만 보여주듯이, 추상화는 문제의 본질에 집중하게 해줍니다. 알고리즘적 사고는 문제 해결 과정을 명확한 단계로 정리하는 능력입니다. "이렇게 하면 되겠지"라는 막연한 생각을 "첫 번째로 이것을, 두 번째로 저것을" 같은 구체적인 계획으로 바꾸는 것입니다.

여러분은 이미 일상에서 이 두 가지를 자연스럽게 사용하고 있습니다. 교통 경로를 찾을 때 모든 골목길을 다 고려하지 않고 주요 도로만 생각하는 것이 추상화입니다. 요리할 때 레시피를 따라 순서대로 진행하는 것이 알고리즘적 사고입니다. 이번 주는 이런 자연스러운 사고 과정을 의식적으로 다듬고, GitHub Copilot에게 효과적으로 전달하는 법을 배웁니다.

### 이번 주 학습 목표

이번 주차가 끝나면 여러분은:
- 복잡한 상황에서 핵심만 추출할 수 있습니다
- 문제 해결 과정을 명확한 단계로 정리할 수 있습니다
- 추상화와 알고리즘을 GitHub Copilot에게 설명할 수 있습니다
- 4대 원리를 통합하여 실제 문제에 적용할 수 있습니다

### 실습의 흐름

오늘 실습은 이렇게 진행됩니다:

**1부: 추상화 연습하기**
- 교통 경로를 단순화하면서 추상화의 기술을 배웁니다
- 좋은 추상화와 나쁜 추상화를 비교합니다
- 여러분만의 추상화 예제를 만들어봅니다

**2부: 알고리즘 훈련하기**
- 레시피를 단계별 지시문으로 바꿔봅니다
- 명확한 단계와 모호한 단계를 구분하는 법을 익힙니다
- 다양한 문제에 알고리즘적 접근을 적용합니다

**3부: 4대 원리 통합 연습**
- 실제 문제에 분해, 패턴 인식, 추상화, 알고리즘을 모두 적용합니다
- 각 원리가 어떻게 서로 연결되는지 이해합니다
- GitHub Copilot과 협업하여 통합적 문제 해결을 경험합니다

지난주와 마찬가지로 먼저 스스로 생각해보고, 예시와 비교하고, 이해한 뒤 직접 적용하는 순서로 진행합니다. 실수는 배움의 일부입니다. 편안한 마음으로 시작해봅시다!

## 추상화: 핵심만 남기는 기술

### 추상화란 무엇인가

추상화는 복잡한 것을 단순하게 만드는 과정입니다. 하지만 단순히 줄이는 것이 아니라, **본질은 유지하면서 불필요한 세부사항만 제거**하는 것입니다. 좋은 추상화는 문제를 더 명확하게 보이게 만듭니다.

일상에서 우리는 항상 추상화를 사용합니다. 친구에게 집 가는 길을 설명할 때를 생각해보세요. "3번째 전봇대에서 왼쪽으로 꺾어서 12보 걷다가..."라고 말하지 않습니다. 대신 "편의점 지나서 왼쪽으로 꺾어"라고 말하죠. 이것이 추상화입니다. 정확한 거리나 모든 건물을 언급하는 대신, 인지하기 쉬운 랜드마크만 사용한 것입니다.

지도도 훌륭한 추상화의 예입니다. 실제 세상에는 나무 한 그루, 돌멩이 하나까지 수없이 많은 것들이 있지만, 지도는 도로, 건물, 지명처럼 길을 찾는 데 필요한 것만 보여줍니다. 지하철 노선도는 더욱 극단적인 추상화입니다. 실제 지리적 위치와 거리를 무시하고, 오직 역의 순서와 환승 정보만 표시합니다. 하지만 이 단순함 덕분에 오히려 더 쉽게 이해할 수 있습니다.

### 추상화의 핵심 원칙

좋은 추상화를 만들기 위한 세 가지 질문이 있습니다:

**1. 무엇이 목적인가?**
- 추상화의 방향을 결정하는 가장 중요한 질문입니다
- 같은 대상도 목적에 따라 다르게 추상화됩니다
- 예: 자동차를 설명할 때
  - 운전자에게: "4인승, 자동변속, 연비 좋은 차"
  - 정비사에게: "엔진 사양, 브레이크 시스템, 배기량"
  - 중고차 구매자에게: "연식, 주행거리, 사고 이력"

**2. 무엇을 남길 것인가?**
- 목적 달성에 꼭 필요한 핵심 정보만 선택합니다
- 이때 "없어도 되는가?"가 아니라 "반드시 있어야 하는가?"를 물어야 합니다
- 의심스러우면 일단 제거하고, 필요하면 다시 추가하는 것이 낫습니다

**3. 무엇을 버릴 것인가?**
- 흥미롭지만 목적과 무관한 정보는 과감히 제거합니다
- 때로는 정확한 정보보다 이해하기 쉬운 근사치가 더 나을 수 있습니다
- 예: "2.7킬로미터" → "약 3킬로미터"

### 실습 1: 교통 경로 단순화하기

이제 실제 예제로 추상화를 연습해봅시다. 다음은 집에서 카페까지 가는 실제 경로입니다:

**원본 (추상화 전):**
```
1. 현관문을 나와서 오른쪽으로 3미터 걸어 엘리베이터 버튼 누르기
2. 엘리베이터를 타고 1층으로 내려가기 (5층에서 출발)
3. 로비를 가로질러 자동문으로 나가기 (약 15미터)
4. 건물 앞 도로에서 오른쪽으로 걸어서 첫 번째 신호등까지 가기 (약 120미터)
5. 신호등에서 횡단보도를 건너서 맞은편으로 가기
6. 맞은편 도로를 따라 계속 직진 (약 200미터)
7. 두 번째 골목길을 지나치고
8. 세 번째 골목에서 왼쪽으로 꺾기
9. 50미터 직진하면 왼쪽에 편의점이 보임
10. 편의점 지나서 20미터 더 가면 오른쪽에 빨간 건물
11. 그 건물 1층에 카페가 있음
```

복잡하죠? 이제 목적에 따라 추상화해봅시다.

**목적 1: 처음 방문하는 친구에게 설명**
```
1. 건물 나와서 오른쪽으로 신호등까지 걸어가세요
2. 횡단보도 건너서 직진하세요
3. 세 번째 골목에서 왼쪽으로 꺾으세요
4. 편의점 지나서 조금 더 가면 빨간 건물 1층에 카페가 있어요
```

무엇이 제거되었나요?
- 정확한 거리 (3미터, 120미터 등)
- 엘리베이터 층수
- 로비의 크기
- 지나치는 골목 개수

무엇이 남았나요?
- 주요 방향 전환점 (신호등, 세 번째 골목)
- 인지하기 쉬운 랜드마크 (편의점, 빨간 건물)
- 핵심 행동 (오른쪽, 횡단보도 건너기, 왼쪽)

**목적 2: 자주 오는 친구에게 간단히 설명**
```
평소 그 카페. 빨간 건물 1층.
```

익숙한 사람에게는 이것만으로도 충분합니다. 이미 경로를 알기 때문입니다.

**목적 3: 배달 앱에 입력할 주소**
```
서울시 강남구 역삼동 123-45 빨간 건물 1층
```

배달원은 네비게이션을 사용하므로 구체적인 경로 대신 정확한 주소가 필요합니다.

### 추상화의 수준 조절하기

같은 내용도 얼마나 추상화하느냐에 따라 다르게 표현됩니다. 추상화 수준이 너무 높으면 정보가 부족하고, 너무 낮으면 복잡해집니다. 적절한 수준을 찾는 것이 중요합니다.

**과도한 추상화 (너무 단순함):**
```
카페로 오세요.
```
→ 처음 오는 사람은 찾을 수 없습니다.

**적절한 추상화:**
```
신호등 건너서 직진, 세 번째 골목 왼쪽, 편의점 지나 빨간 건물 1층
```
→ 핵심 랜드마크와 방향이 있어 찾을 수 있습니다.

**불충분한 추상화 (너무 복잡함):**
```
엘리베이터 타고 1층 내려서 로비 15미터 가로질러 자동문 나가서...
```
→ 불필요한 세부사항이 너무 많아 오히려 혼란스럽습니다.

### 실습 2: 여러분의 추상화 만들기

이제 직접 해볼 차례입니다. 다음 상황을 추상화해보세요:

**과제: 온라인 쇼핑 과정 추상화하기**

아래는 온라인으로 옷을 구매하는 전체 과정입니다:

```
1. 컴퓨터를 켜고 브라우저를 실행한다
2. 쇼핑몰 웹사이트 주소를 입력한다
3. 아이디와 비밀번호를 입력해 로그인한다
4. 상단 메뉴에서 '여성복'을 클릭한다
5. '상의' 카테고리를 선택한다
6. 필터에서 가격 범위를 5만원~10만원으로 설정한다
7. 색상 필터에서 '검정'을 선택한다
8. 검색 결과를 '인기순'으로 정렬한다
9. 첫 번째 상품의 상세 페이지로 들어간다
10. 상품 이미지를 하나하나 확대해서 본다
11. 상품 설명을 읽는다
12. 구매 후기를 읽는다
13. 사이즈 M을 선택한다
14. '장바구니에 담기' 버튼을 클릭한다
15. 계속 쇼핑할지 물어보면 '장바구니 가기'를 선택한다
16. 장바구니에서 수량을 확인한다
17. 할인 쿠폰을 입력한다
18. '주문하기' 버튼을 클릭한다
19. 배송지 주소를 확인한다
20. 결제 방법을 선택한다 (신용카드)
21. 카드 번호를 입력한다
22. 유효기간과 CVC 번호를 입력한다
23. '결제하기' 버튼을 클릭한다
24. 결제 완료 문자를 확인한다
```

잠시 생각해보세요. 이 과정을 다음 목적에 맞게 추상화한다면 어떻게 할까요?

**목적 A: 온라인 쇼핑이 처음인 부모님께 설명**
(스스로 작성해보세요)

**목적 B: 쇼핑몰 개발자에게 주요 기능 설명**
(스스로 작성해보세요)

**목적 C: GitHub Copilot에게 비슷한 쇼핑몰 만들어달라고 요청**
(스스로 작성해보세요)

준비되셨나요? 다음 페이지에서 예시 답안을 보겠습니다.

### 추상화 예시 답안

**목적 A: 온라인 쇼핑이 처음인 부모님께 설명**
```
1. 쇼핑몰 사이트에 접속해서 로그인하세요
2. 원하는 카테고리를 찾아 들어가세요
3. 마음에 드는 상품을 클릭해서 자세히 보세요
4. '장바구니에 담기'를 누르세요
5. 장바구니에서 '주문하기'를 누르세요
6. 배송지를 확인하고 결제 방법을 선택하세요
7. 카드 정보를 입력하고 결제하세요
```

**왜 이렇게 추상화했나요?**
- 기술적 용어 제거: "브라우저"를 "사이트에 접속"으로
- 세부 조작 생략: 필터 설정, 정렬 등은 생략하고 "원하는 카테고리"로 통합
- 핵심 단계만 유지: 접속 → 검색 → 선택 → 결제의 큰 흐름
- 각 단계를 명확한 행동으로 표현: "~하세요"

**목적 B: 쇼핑몰 개발자에게 주요 기능 설명**
```
1. 회원 인증 시스템
2. 상품 카테고리 탐색 및 필터링 (가격, 색상, 정렬)
3. 상품 상세 정보 제공 (이미지, 설명, 후기)
4. 장바구니 관리
5. 주문 및 결제 처리 (쿠폰, 배송지, 결제 수단)
```

**왜 이렇게 추상화했나요?**
- 사용자 행동이 아닌 시스템 기능으로 표현
- 기술적 용어 사용 가능: "인증", "필터링", "결제 처리"
- 구현해야 할 모듈 단위로 그룹화
- 구체적인 UI 조작 대신 제공해야 할 기능에 집중

**목적 C: GitHub Copilot에게 비슷한 쇼핑몰 만들어달라고 요청**
```
사용자가 다음 작업을 할 수 있는 온라인 쇼핑몰을 만들어주세요:
- 카테고리별로 상품을 탐색하고 가격/색상으로 필터링
- 상품 상세 정보(이미지, 설명, 후기)를 확인
- 장바구니에 상품을 담고 관리
- 배송지를 입력하고 할인 쿠폰을 적용
- 신용카드로 결제

필요한 주요 화면:
- 상품 목록 페이지
- 상품 상세 페이지
- 장바구니 페이지
- 주문/결제 페이지
```

**왜 이렇게 추상화했나요?**
- 무엇을 만들어야 하는지 명확히 제시
- 기능을 목록으로 구조화
- 화면 단위로 결과물을 구체화
- 세부 구현 방법은 Copilot에게 위임

### GitHub Copilot에게 추상화 전달하기

추상화를 잘했다면, 이제 이것을 GitHub Copilot에게 효과적으로 전달할 차례입니다. 추상화된 내용을 프롬프트로 바꾸는 팁을 알려드리겠습니다.

**팁 1: 목적을 먼저 밝히기**
```
나쁜 예:
"쇼핑 기능을 만들어줘"

좋은 예:
"초보자도 쉽게 사용할 수 있는 간단한 온라인 쇼핑 기능을 만들어줘"
```

목적이 명확하면 Copilot이 적절한 수준의 복잡도로 만듭니다.

**팁 2: 핵심 기능을 목록으로 제시하기**
```
다음 핵심 기능이 필요해:
- 상품 검색 및 필터링
- 장바구니 관리
- 간편한 결제 과정
```

목록은 Copilot이 이해하기 쉽고, 빠뜨리지 않고 구현하도록 도와줍니다.

**팁 3: 제외할 것도 명시하기**
```
복잡한 회원 등급 시스템이나 포인트 적립은 필요 없어.
기본적인 로그인과 주문 기능만 있으면 돼.
```

무엇을 하지 말아야 하는지 알려주면 불필요한 복잡함을 피할 수 있습니다.

**팁 4: 결과물의 형태 설명하기**
```
결과물은 다음과 같은 화면들로 구성돼:
1. 상품 목록 화면
2. 상품 상세 화면
3. 장바구니 화면
4. 결제 화면
```

구체적인 결과 이미지를 주면 Copilot이 방향을 잡기 쉽습니다.

### 실습 3: 추상화를 프롬프트로 바꾸기

이제 여러분이 직접 해볼 차례입니다. 다음 상황을 추상화하고, GitHub Copilot에게 전달할 프롬프트로 만들어보세요.

**상황: 개인 일정 관리 프로그램 만들기**

여러분은 매일 해야 할 일들을 관리하는 간단한 프로그램이 필요합니다. 다음과 같은 것들을 할 수 있어야 합니다:
- 할 일을 추가하고 날짜 지정하기
- 완료한 일은 체크 표시하기
- 중요한 일은 별표로 강조하기
- 오늘, 이번 주, 전체 일정을 볼 수 있기
- 완료된 일은 목록에서 숨기거나 보이게 하기
- 할 일에 간단한 메모 추가하기
- 마감일이 지난 일은 빨간색으로 표시하기
- 카테고리별로 분류하기 (업무, 개인, 쇼핑 등)

이제 이것을 추상화하세요. 어떤 것이 핵심이고, 어떤 것을 먼저 만들어야 할까요?

**1단계: 핵심 기능만 추출하기**
(스스로 작성해보세요)

**2단계: GitHub Copilot에게 전달할 프롬프트 작성하기**
(스스로 작성해보세요)

다음 페이지에서 예시를 보겠습니다.

### 프롬프트 작성 예시

**1단계: 핵심 기능 추출**

**반드시 필요한 기능 (1순위):**
- 할 일 추가하기
- 완료 표시하기
- 할 일 목록 보기

**있으면 좋은 기능 (2순위):**
- 날짜 지정하기
- 중요 표시하기
- 완료된 일 숨기기/보이기

**나중에 추가해도 되는 기능 (3순위):**
- 메모 추가
- 마감일 경고
- 카테고리 분류

**2단계: GitHub Copilot용 프롬프트**

```
간단한 할 일 관리 프로그램을 만들어주세요.

핵심 기능:
- 할 일을 추가하고 목록으로 보기
- 완료한 일은 체크 표시하기
- 날짜를 지정할 수 있고, 중요한 일은 별표로 강조하기
- 완료된 일을 숨기거나 보이게 할 수 있기

처음에는 복잡한 기능(카테고리 분류, 상세 메모 등)은 빼고,
위의 핵심 기능만 잘 작동하도록 만들어주세요.

사용자 인터페이스는 심플하게, 누구나 쉽게 쓸 수 있도록 해주세요.
```

**왜 이렇게 작성했나요?**
- 명확한 목적: "간단한 할 일 관리"
- 핵심만 강조: 3-4개의 주요 기능
- 제외할 것 명시: "복잡한 기능은 빼고"
- 결과물 가이드: "심플하게"

이렇게 추상화하면 Copilot이 핵심에 집중한 코드를 만듭니다. 나중에 필요하면 추가 기능을 요청할 수 있습니다.

## 알고리즘적 사고: 단계별 해결책 만들기

### 알고리즘적 사고란 무엇인가

알고리즘적 사고는 문제를 해결하는 과정을 명확한 단계로 정리하는 능력입니다. 막연한 "이렇게 하면 되겠지"를 구체적인 "첫 번째로 이것을, 두 번째로 저것을, 만약 이런 상황이면 이렇게"로 바꾸는 것입니다.

여러분은 이미 알고리즘적으로 사고하고 있습니다. 아침에 커피를 만들 때, 출근 준비를 할 때, 여러분의 머릿속에는 자연스러운 순서가 있습니다. 다만 평소에는 의식하지 못할 뿐입니다. 알고리즘적 사고는 이런 무의식적인 과정을 의식적으로 정리하는 것입니다.

좋은 알고리즘의 특징은 다음과 같습니다:
- **명확성**: 각 단계가 무엇을 의미하는지 모호하지 않습니다
- **순서**: 단계들이 논리적인 순서로 배열되어 있습니다
- **완결성**: 시작부터 끝까지 모든 과정이 포함되어 있습니다
- **실행 가능성**: 실제로 수행할 수 있는 구체적인 행동들입니다

### 일상 속 알고리즘 찾기

레시피는 훌륭한 알고리즘의 예입니다. 김치찌개 레시피를 봅시다:

**모호한 레시피:**
```
김치찌개를 만든다. 김치와 돼지고기를 적당히 넣고 끓인다.
양념을 해서 맛을 낸다.
```

이 레시피로 요리할 수 있을까요? 경험이 많은 사람은 가능하겠지만, 처음 만드는 사람은 어려울 것입니다. "적당히"가 얼마인지, "양념"이 무엇인지 불명확하기 때문입니다.

**명확한 알고리즘:**
```
1. 준비하기
   - 김치 200g을 한입 크기로 자르기
   - 돼지고기 150g을 한입 크기로 자르기
   - 두부 반 모를 2cm 두께로 자르기
   - 대파 1대를 송송 썰기

2. 볶기
   - 냄비에 식용유 1큰술을 두르기
   - 돼지고기를 넣고 중불에서 2분간 볶기
   - 김치를 넣고 3분 더 볶기

3. 끓이기
   - 물 3컵을 붓기
   - 고춧가루 1큰술, 다진 마늘 1큰술 넣기
   - 뚜껑을 덮고 센불에서 끓이기
   - 끓기 시작하면 중불로 줄이고 10분간 더 끓이기

4. 마무리하기
   - 두부를 넣고 5분간 끓이기
   - 대파를 넣고 1분간 끓이기
   - 간을 보고 필요하면 소금으로 간 맞추기
```

무엇이 달라졌나요?
- **구체적인 양**: "적당히" → "200g", "3컵", "1큰술"
- **명확한 행동**: "양념한다" → "고춧가루 1큰술, 다진 마늘 1큰술 넣기"
- **시간 명시**: "끓인다" → "10분간 끓이기"
- **단계 구분**: 준비, 볶기, 끓이기, 마무리로 구조화
- **조건 포함**: "끓기 시작하면", "필요하면"

### 좋은 알고리즘의 조건

알고리즘을 만들 때 다음을 확인해보세요:

**1. 각 단계가 하나의 행동인가?**
```
나쁜 예:
"재료를 준비하고 요리한다"
→ 너무 큰 단계, 여러 행동이 섞여 있음

좋은 예:
"1. 재료를 자른다"
"2. 냄비에 재료를 넣는다"
"3. 끓인다"
→ 각 단계가 명확한 하나의 행동
```

**2. 순서가 바뀌면 안 되는가?**
```
순서가 중요한 경우:
1. 물을 끓인다
2. 라면을 넣는다
→ 순서를 바꾸면 제대로 안 됨

순서가 덜 중요한 경우:
1. 양파를 자른다
2. 당근을 자른다
→ 순서를 바꿔도 결과는 같음
```

**3. 조건과 선택이 명확한가?**
```
모호한 조건:
"맛을 보고 필요하면 조절한다"
→ 무엇을, 어떻게 조절하는지 불명확

명확한 조건:
"국물을 맛본다"
"짜면: 물 반 컵 추가"
"싱거우면: 소금 반 작은술 추가"
→ 조건과 행동이 구체적
```

**4. 끝이 명확한가?**
```
불명확한 끝:
"계속 저으면서 익힌다"
→ 언제까지?

명확한 끝:
"5분간 저으면서 익힌다"
"또는: 거품이 사라질 때까지 저으면서 익힌다"
→ 종료 조건이 분명함
```

### 실습 4: 레시피를 알고리즘으로

이제 여러분이 직접 해볼 차례입니다. 다음 모호한 레시피를 명확한 알고리즘으로 바꿔보세요.

**과제: 계란 프라이 만들기**

```
계란 프라이를 만든다.
팬을 달구고 기름을 두른다.
계란을 깨서 넣는다.
적당히 익히고 그릇에 담는다.
```

여러분이라면 어떻게 바꾸시겠어요? 다음 질문들을 고려해보세요:

- 팬을 얼마나 달궈야 할까요?
- 기름은 얼마나 넣어야 할까요?
- 계란을 어떻게 깨야 할까요?
- "적당히"는 구체적으로 무엇일까요?
- 어떤 상태가 되면 완성일까요?

종이에 여러분의 알고리즘을 작성해보세요. 그리고 다음 페이지의 예시와 비교해봅시다.

### 계란 프라이 알고리즘 예시

**예시 답안:**

```
1. 준비하기
   - 계란 1개 꺼내기
   - 작은 그릇 하나 준비하기 (계란 깨서 담을 용도)
   - 접시 하나 준비하기

2. 팬 예열하기
   - 프라이팬을 중불에 올리기
   - 30초 정도 기다리기
   - 손을 팬 위에 대봤을 때 따뜻함이 느껴지면 준비 완료

3. 기름 두르기
   - 식용유 1큰술을 팬에 두르기
   - 팬을 살짝 기울여 기름이 고르게 퍼지게 하기

4. 계란 깨기
   - 계란을 작은 그릇에 깨서 담기
   - 껍질 조각이 있는지 확인하기
   - 있다면 제거하기

5. 계란 넣기
   - 그릇의 계란을 팬 중앙에 천천히 붓기
   - 불을 약중불로 줄이기

6. 익히기
   두 가지 방법 중 선택:
   
   방법 A - 반숙:
   - 2분간 그대로 두기
   - 흰자가 하얗게 익고 노른자가 반쯤 익으면 완성
   
   방법 B - 완숙:
   - 2분간 두기
   - 뚜껑을 덮고 1분 더 익히기
   - 노른자까지 완전히 익으면 완성

7. 마무리하기
   - 뒤집개로 계란을 조심스럽게 들어 올리기
   - 접시에 담기
   - 원한다면 소금, 후추로 간하기
```

**이 알고리즘의 특징:**
- 구체적인 시간 명시: "30초", "2분"
- 판단 기준 제공: "따뜻함이 느껴지면", "하얗게 익으면"
- 선택 옵션 제공: 반숙/완숙 두 가지 방법
- 예외 처리: 껍질 조각 확인 및 제거
- 단계별 구분: 준비-예열-기름-깨기-넣기-익히기-마무리

### 알고리즘의 조건 처리

좋은 알고리즘은 다양한 상황을 고려합니다. 레시피의 "만약...이라면" 같은 조건들이 이에 해당합니다.

**조건 유형 1: 상태 확인**
```
흰자가 완전히 익었는가?
예 → 다음 단계로
아니오 → 30초 더 기다리기
```

**조건 유형 2: 선택 분기**
```
어떤 스타일을 원하는가?
반숙 → 2분만 익히기
완숙 → 뚜껑 덮고 3분 익히기
```

**조건 유형 3: 예외 처리**
```
계란 껍질이 들어갔는가?
예 → 제거하기
아니오 → 그대로 진행
```

**조건 유형 4: 반복**
```
소금 간이 충분한가?
아니오 → 소금 조금 추가하고 다시 확인
예 → 완성
```

### 실습 5: 일상을 알고리즘으로

이제 요리가 아닌 다른 일상 활동을 알고리즘으로 만들어봅시다.

**과제: 아침에 출근 준비하기**

아침에 일어나서 집을 나설 때까지의 과정을 명확한 알고리즘으로 작성하세요. 다음을 고려하세요:

**필수 단계:**
- 기상
- 씻기
- 옷 입기
- 아침 먹기
- 집 나서기

**고려할 조건:**
- 시간이 부족하면?
- 날씨에 따라 옷이 달라진다면?
- 오늘 중요한 일정이 있다면?

스스로 작성해보세요. 실제로 여러분이 하는 방식을 단계로 정리하면 됩니다. 5-10분 정도 투자해서 종이에 적어보세요.

완성했나요? 다음은 참고할 수 있는 예시입니다.

### 출근 준비 알고리즘 예시

```
1. 기상하기 (목표 시간: 7:00)
   - 알람이 울리면 바로 일어나기
   - 만약 5분 더 자고 싶다면:
     → 알람을 7:05로 재설정 (한 번만 허용)
     → 일어나서 커튼 열기 (빛으로 잠 깨우기)
   
2. 씻기 (소요 시간: 15분)
   - 화장실 가기
   - 세수하기
   - 양치하기
   - 머리 감기 여부 확인:
     → 오늘 중요한 일정 있음 → 머리 감기
     → 없음 → 건너뛰기

3. 날씨 확인하기 (소요 시간: 1분)
   - 핸드폰으로 오늘 날씨 확인
   - 결과 기억하기 (옷 선택에 사용)

4. 옷 입기 (소요 시간: 5분)
   날씨에 따라:
   - 비 예보 있음 → 방수 재킷 준비
   - 추움 (15도 이하) → 겉옷 챙기기
   - 더움 (25도 이상) → 얇은 옷 입기
   
   일정에 따라:
   - 중요한 회의 있음 → 정장 또는 깔끔한 옷
   - 평소 업무 → 편한 옷

5. 아침 먹기 (소요 시간: 10분)
   시간 확인:
   - 7:30 이전 → 간단한 아침 먹기
   - 7:30 이후 → 우유나 바나나 챙겨서 가기
   - 7:40 이후 → 아침 건너뛰기, 출근길에 사먹기

6. 가방 챙기기 (소요 시간: 3분)
   필수 항목 확인:
   - 지갑
   - 핸드폰
   - 키
   - 노트북 (필요시)
   - 우산 (비 예보 시)

7. 집 나서기
   최종 확인:
   - 불 끄기 확인
   - 가스 잠금 확인
   - 창문 닫기 확인
   - 현관문 잠그기
```

**이 알고리즘의 특징:**
- **시간 관리**: 각 단계의 소요 시간 표시
- **유연한 조건**: 상황에 따라 다른 선택
- **우선순위**: 시간이 부족할 때 무엇을 생략할지 명확
- **체크리스트**: 잊지 말아야 할 것들을 마지막에 확인

### GitHub Copilot에게 알고리즘 전달하기

이제 여러분이 만든 알고리즘을 GitHub Copilot에게 전달하여 실제 프로그램으로 만드는 방법을 배워봅시다.

**기본 원칙:**
1. 단계를 순서대로 설명하기
2. 조건과 선택을 명확히 하기
3. 예외 상황 설명하기
4. 원하는 결과물 형태 제시하기

**예제: 아침 알람 프로그램 만들기**

여러분이 GitHub Copilot에게 이렇게 요청할 수 있습니다:

```
아침 알람 프로그램을 만들어주세요. 다음 기능이 필요합니다:

1. 사용자가 알람 시간을 설정할 수 있어야 합니다
2. 설정된 시간에 알람이 울립니다
3. 사용자가 "5분 더" 버튼을 누르면:
   - 알람이 5분 뒤로 재설정됩니다
   - 하지만 이 기능은 1회만 사용 가능합니다
   - 2번째부터는 "5분 더" 버튼이 비활성화됩니다
4. "일어나기" 버튼을 누르면:
   - 알람이 멈춥니다
   - "좋은 아침입니다!" 메시지를 보여줍니다

화면 구성:
- 시간 설정 입력란
- 알람 설정 버튼
- 알람이 울릴 때: "5분 더" 버튼과 "일어나기" 버튼

간단하고 사용하기 쉽게 만들어주세요.
```

**왜 이렇게 작성했나요?**
- 각 기능을 번호로 구분: Copilot이 단계별로 이해
- 조건을 명확히 표현: "하지만", "2번째부터는"
- 결과를 구체화: "메시지를 보여줍니다"
- UI 요소 나열: 필요한 화면 구성을 미리 제시

### 실습 6: 여러분의 알고리즘을 프롬프트로

앞에서 작성한 "출근 준비" 알고리즘을 바탕으로, GitHub Copilot에게 "아침 루틴 도우미" 프로그램을 만들어달라고 요청하는 프롬프트를 작성해보세요.

**프로그램이 해야 할 일:**
- 각 단계의 소요 시간 추적
- 현재 어느 단계인지 표시
- 전체 남은 시간 계산
- 시간이 부족하면 경고
- 각 단계 완료 시 체크

종이에 프롬프트를 작성해보세요. 다음 페이지에서 예시를 보겠습니다.

### 프롬프트 예시: 아침 루틴 도우미

```
아침 출근 준비를 도와주는 간단한 프로그램을 만들어주세요.

기능:
1. 사용자가 "집에서 나가야 할 시간"을 입력합니다
2. 프로그램은 각 단계와 소요 시간을 보여줍니다:
   - 씻기 (15분)
   - 옷 입기 (5분)
   - 아침 먹기 (10분)
   - 가방 챙기기 (3분)
   합계: 33분

3. 현재 시간을 기준으로 "지금 시작해야 하는 시간"을 계산해서 보여줍니다
   예: 8시에 나가야 한다면 → "7시 27분에 시작하세요"

4. 각 단계를 하나씩 보여주고, 완료하면 체크 표시를 합니다

5. 시간 확인 기능:
   - 현재 진행 상황을 보고 예상 완료 시간을 계산합니다
   - 만약 늦을 것 같으면:
     → 빨간색으로 경고 메시지를 보여줍니다
     → "아침 식사를 건너뛰시겠습니까?" 같은 제안을 합니다

화면 구성:
- 상단: 목표 시간과 남은 시간
- 중간: 단계 목록 (체크박스와 소요 시간 표시)
- 하단: 현재 상태 메시지

복잡한 기능은 필요 없고, 핵심 기능만 잘 작동하면 됩니다.
간단하고 직관적인 인터페이스로 만들어주세요.
```

**이 프롬프트의 장점:**
- 명확한 입력/출력: 무엇을 입력하고 무엇을 보여줄지 설명
- 계산 로직 설명: "지금 시작해야 하는 시간" 계산 방법
- 조건 처리: 늦을 때의 동작 명시
- UI 구조: 화면 배치 가이드
- 범위 제한: "복잡한 기능은 필요 없고"로 범위 한정

## GitHub Copilot과 함께 4대 원리 통합하기

### 4대 원리는 어떻게 함께 작동하는가

지금까지 컴퓨팅 사고의 4대 원리를 하나씩 배웠습니다. 이제 이들을 통합하여 사용하는 방법을 익힐 차례입니다. 실제 문제를 해결할 때는 이 원리들을 따로따로 쓰는 것이 아니라 자연스럽게 함께 사용합니다.

4대 원리가 협력하는 방식을 이해하기 위해, 실제 문제 하나를 처음부터 끝까지 해결해봅시다.

### 실전 예제: 가계부 자동 분석 프로그램

**상황:**
매달 신용카드 내역서를 받지만, 어디에 돈을 많이 쓰는지 파악하기 어렵습니다. 항목이 수백 개나 되고, 가게 이름도 제각각입니다. 지출 패턴을 쉽게 파악할 수 있는 프로그램이 필요합니다.

**원본 문제 (복잡한 상태):**
```
신용카드 내역:
2024-01-05, 스타벅스 강남점, 6,500원
2024-01-05, GS25 편의점, 3,200원
2024-01-06, 올리브영 명동점, 45,000원
2024-01-06, 배달의민족-치킨, 23,000원
2024-01-07, 쿠팡-생활용품, 78,000원
2024-01-08, 스타벅스 역삼점, 5,500원
... (수백 개 항목)

이것을 어떻게 분석할까요?
```

이제 4대 원리를 순서대로 적용해봅시다.

**Agent 모드 활용 팁:**
こ런 복잡한 분석 프로그램은 Agent 모드가 특히 유용합니다:
- `@workspace`를 사용하면 Agent가 전체 프로젝트를 이해하고 여러 파일을 동시에 만들어줍니다
- 데이터 파일, 분석 로직, 시각화 코드를 각각 분리해서 관리할 수 있습니다
- "데이터 읽기 부분만 수정해줘" 같은 요청으로 특정 모듈만 개선할 수 있습니다

### 1단계: 분해 (Decomposition)

큰 문제를 작은 문제로 나눕니다.

**전체 문제를 단계로 나누기:**
```
1. 데이터 읽어오기
   - 신용카드 내역 파일 불러오기
   - 각 행을 날짜, 가게, 금액으로 나누기

2. 데이터 정리하기
   - 가게 이름을 카테고리로 분류하기
   - 금액을 숫자로 변환하기

3. 분석하기
   - 카테고리별 총액 계산하기
   - 월별 지출 추이 보기
   - 가장 많이 쓴 카테고리 찾기

4. 결과 보여주기
   - 차트나 표로 시각화하기
   - 간단한 요약 제공하기
```

각 단계는 독립적으로 해결할 수 있습니다. 이것이 분해의 힘입니다.

### 2단계: 패턴 인식 (Pattern Recognition)

데이터에서 반복되는 규칙을 찾습니다.

**발견한 패턴들:**
```
패턴 1: 가게 이름에 규칙이 있음
- "스타벅스", "투썸플레이스" → 카페
- "GS25", "CU", "세븐일레븐" → 편의점
- "올리브영", "다이소" → 생활용품
- "배달의민족", "요기요" → 배달음식

패턴 2: 날짜에서 요일 패턴
- 주말에 배달음식 지출이 많음
- 평일 점심시간에 카페 지출

패턴 3: 금액 범위 패턴
- 5천원~1만원: 주로 카페, 편의점
- 2만원~5만원: 주로 음식, 생활용품
- 5만원 이상: 주로 쇼핑, 온라인 구매
```

이 패턴들은 자동 분류의 기준이 됩니다.

### 3단계: 추상화 (Abstraction)

핵심만 남기고 세부사항을 제거합니다.

**세부 정보에서 핵심으로:**
```
추상화 전:
- "스타벅스 강남점", "스타벅스 역삼점", "스타벅스 서초점"

추상화 후:
- "카페" 카테고리로 통합

추상화 전:
- 정확한 금액: 6,500원, 5,500원, 6,300원

추상화 후 (용도에 따라):
- 분석용: "카페" 카테고리의 총액
- 시각화용: "만원 미만 소액 지출"
```

**불필요한 정보 제거:**
```
분석에 필요 없는 것들:
- 가게의 정확한 지점명 (강남점, 역삼점 등)
- 결제 시간 (날짜만 있으면 충분)
- 결제 방법 (신용카드로 통일)
- 승인 번호

남겨야 할 것들:
- 날짜 (추이 분석에 필요)
- 카테고리 (분류의 핵심)
- 금액 (계산에 필수)
```

### 4단계: 알고리즘 (Algorithmic Thinking)

해결 과정을 명확한 단계로 정리합니다.

**구체적인 알고리즘:**
```
1. 데이터 읽기
   - 파일을 열기
   - 각 줄을 읽기
   - 날짜, 가게, 금액으로 분리하기
   - 리스트에 저장하기

2. 카테고리 분류하기
   각 항목에 대해:
   - 가게 이름을 확인하기
   - 만약 "스타벅스" 또는 "카페" 포함 → "카페"로 분류
   - 만약 "GS25" 또는 "CU" 포함 → "편의점"으로 분류
   - 만약 "배달" 포함 → "배달음식"으로 분류
   - ... (다른 카테고리도 동일)
   - 해당 없으면 → "기타"로 분류

3. 카테고리별 합계 계산
   - 빈 결과 저장소 만들기 (카테고리: 0원)
   - 각 항목에 대해:
     → 해당 카테고리의 금액에 더하기
   
4. 결과 정렬 및 표시
   - 금액이 큰 순서대로 정렬하기
   - 각 카테고리와 금액 출력하기
   - 전체 합계 출력하기
```

### 통합 적용: 프롬프트 만들기

이제 4대 원리를 모두 사용하여 GitHub Copilot에게 전달할 프롬프트를 만들어봅시다.

**4대 원리가 통합된 프롬프트:**

```
신용카드 지출 내역을 분석하는 프로그램을 만들어주세요.

입력 데이터 형식:
날짜, 가게명, 금액
예: "2024-01-05, 스타벅스 강남점, 6500"

프로그램이 해야 할 일:

1. 데이터 읽기
   - 파일에서 각 줄을 읽어옵니다
   - 쉼표로 구분하여 날짜, 가게명, 금액으로 나눕니다

2. 자동 분류
   가게 이름을 보고 카테고리로 분류합니다:
   - "스타벅스", "투썸", "카페" → "카페"
   - "GS25", "CU", "세븐일레븐" → "편의점"
   - "배달", "요기요" → "배달음식"
   - "올리브영", "다이소" → "생활용품"
   - "쿠팡", "온라인" → "온라인쇼핑"
   - 기타 → "기타"

3. 분석 및 계산
   - 각 카테고리별 총 지출액 계산
   - 전체 지출액 계산
   - 금액이 큰 순서로 정렬

4. 결과 표시
   다음과 같은 형식으로 보여주세요:
   ```
   === 카테고리별 지출 분석 ===
   1. 온라인쇼핑: 150,000원 (30%)
   2. 배달음식: 120,000원 (24%)
   3. 카페: 80,000원 (16%)
   ...
   
   전체 지출: 500,000원
   ```

간단하고 명확한 코드로 작성해주세요.
파일 입출력 부분은 나중에 추가할 수 있으니,
일단 데이터가 리스트로 주어진다고 가정하고 만들어주세요.
```

**이 프롬프트가 효과적인 이유:**

**분해가 반영됨:**
- 전체 작업을 4단계로 명확히 구분
- 각 단계가 독립적으로 이해 가능

**패턴 인식이 반영됨:**
- 가게 이름의 패턴을 활용한 분류 규칙 제시
- 예시로 구체적인 패턴 명시

**추상화가 반영됨:**
- 정확한 지점명 무시하고 카테고리만 사용
- 세부 시간 대신 날짜만 사용
- 백분율로 비율 표시 (간단한 이해)

**알고리즘이 반영됨:**
- 단계별로 무엇을 어떻게 할지 명시
- 조건 분기 명확히 표현 ("만약...이면")
- 최종 결과 형식까지 구체적으로 제시

### 실습 7: 통합 연습

이제 여러분이 4대 원리를 통합하여 문제를 해결해볼 차례입니다.

**과제: 독서 기록 관리 프로그램**

**상황:**
책을 많이 읽는데, 어떤 책을 언제 읽었는지 기억이 잘 안 납니다. 간단한 독서 기록을 남기고 싶은데, 다음 정보를 관리하고 싶습니다:

```
책 제목, 저자, 시작일, 완독일, 평점(5점 만점), 짧은 메모
```

원하는 기능:
- 읽은 책 목록 보기
- 월별로 몇 권 읽었는지 보기
- 평점 높은 책 추천
- 같은 저자의 책 찾기

**여러분의 과제:**

1. **분해**: 이 문제를 4-5개의 주요 단계로 나누세요
2. **패턴 인식**: 어떤 패턴을 활용할 수 있을까요? (날짜, 저자, 평점 등)
3. **추상화**: 어떤 정보가 핵심이고, 무엇을 제외할 수 있을까요?
4. **알고리즘**: 각 기능을 단계별로 어떻게 구현할까요?
5. **프롬프트**: 이 모든 것을 GitHub Copilot에게 전달하는 프롬프트를 작성하세요

종이에 각 단계를 작성해보세요. 완벽할 필요는 없습니다. 여러분의 생각을 정리하는 것이 중요합니다.

준비되었나요? 다음 페이지에서 예시 답안을 보겠습니다.

### 독서 기록 관리 예시 답안

**1. 분해 (Decomposition)**

```
주요 단계:
1. 독서 기록 저장하기
2. 기록 목록 보기
3. 통계 분석하기 (월별, 평점별)
4. 검색 기능 (저자, 제목)
5. 결과 표시하기
```

**2. 패턴 인식 (Pattern Recognition)**

```
발견할 수 있는 패턴:
- 시간 패턴: 특정 월에 독서량이 많음
- 저자 패턴: 같은 저자의 책을 여러 권 읽음
- 평점 패턴: 평점 4점 이상은 추천할 만한 책
- 장르 패턴: 책 제목이나 출판사로 장르 유추 가능
- 독서 속도: 시작일-완독일 차이로 읽는 속도 계산
```

**3. 추상화 (Abstraction)**

```
핵심 정보 (반드시 필요):
- 책 제목
- 저자
- 완독 여부
- 평점

부가 정보 (있으면 좋음):
- 시작일/완독일
- 짧은 메모

제외할 정보 (너무 복잡함):
- 출판사, ISBN
- 정확한 페이지 수
- 상세한 리뷰
- 책 가격

추상화된 카테고리:
"읽은 책" vs "읽는 중" vs "읽고 싶은 책"
```

**4. 알고리즘 (Algorithmic Thinking)**

```
기능 1: 책 추가하기
1. 책 제목 입력받기
2. 저자 입력받기
3. 시작일 입력받기 (선택)
4. 완독 여부 확인
5. 완독했다면:
   - 완독일 입력받기
   - 평점 입력받기 (1-5점)
   - 메모 입력받기 (선택)
6. 목록에 저장하기

기능 2: 월별 통계 보기
1. 모든 기록 가져오기
2. 완독일 기준으로 월별로 분류하기
3. 각 월의 책 개수 세기
4. 월 순서대로 정렬하기
5. 결과 표시하기:
   "2024년 1월: 3권"
   "2024년 2월: 5권"

기능 3: 높은 평점 책 추천
1. 모든 기록 가져오기
2. 평점 4점 이상만 필터링하기
3. 평점 높은 순으로 정렬하기
4. 상위 5권 보여주기

기능 4: 저자로 검색
1. 저자 이름 입력받기
2. 모든 기록에서 저자 이름 비교하기
3. 일치하는 책들 찾기
4. 결과 목록 보여주기
```

**5. 통합 프롬프트**

```
독서 기록을 관리하는 간단한 프로그램을 만들어주세요.

데이터 구조:
각 책 기록은 다음 정보를 포함합니다:
- 제목 (필수)
- 저자 (필수)
- 시작일 (선택)
- 완독일 (완독한 경우 필수)
- 평점 1-5점 (완독한 경우 필수)
- 메모 (선택)

필요한 기능:

1. 책 추가하기
   - 위 정보들을 입력받아 저장
   - 완독하지 않은 책은 "읽는 중" 상태로 표시

2. 목록 보기
   - 모든 책을 표시
   - 완독한 책과 읽는 중인 책을 구분하여 표시
   - 평점이 있는 책은 별(★)로 표시

3. 월별 통계
   - 완독일을 기준으로 월별로 몇 권 읽었는지 계산
   - "2024년 1월: 3권" 형식으로 표시

4. 추천 도서 (평점 4점 이상)
   - 평점 4점 이상인 책만 필터링
   - 평점 높은 순으로 표시

5. 저자 검색
   - 저자 이름을 입력하면 그 저자의 모든 책을 찾기
   - 읽은 책과 읽는 중인 책 모두 포함

출력 형식 예시:
```
=== 읽은 책 목록 ===
1. 클린 코드 - 로버트 마틴 ★★★★★
   완독: 2024-01-15
   메모: 코딩 스타일 개선에 큰 도움

2. 이펙티브 자바 - 조슈아 블로크 ★★★★
   완독: 2024-01-28
```

복잡한 검색 기능이나 데이터베이스는 필요 없습니다.
간단한 리스트로 관리하고, 기본 기능만 잘 작동하면 됩니다.
```

**이 프롬프트의 특징:**

- **명확한 구조**: 데이터 형식부터 제시
- **기능별 설명**: 각 기능이 무엇을 하는지 구체적으로
- **출력 예시**: 결과물이 어떻게 보여야 하는지 명시
- **범위 한정**: "복잡한 기능은 필요 없다"로 과도한 구현 방지
- **우선순위**: 핵심 기능 강조

### 실습 8: GitHub Copilot과 실제로 해보기

이제 GitHub Copilot을 열고 앞에서 만든 프롬프트 중 하나를 실제로 시도해보세요.

**추천 순서:**

1. **간단한 것부터**: 아침 알람이나 할 일 관리처럼 단순한 것으로 시작
2. **프롬프트 입력**: 작성한 프롬프트를 Copilot에게 전달
3. **결과 확인**: Copilot이 만든 코드를 실행해보기 (코드를 읽을 필요는 없음)
4. **개선 요청**: 원하는 대로 작동하지 않으면 추가 설명
5. **반복**: 만족할 때까지 대화하며 개선

**Copilot과 대화하는 팁:**

```
처음 요청: (작성한 프롬프트 전체)

만약 결과가 복잡하다면:
"더 간단하게 만들어줘. 핵심 기능만 있으면 돼."

만약 기능이 빠졌다면:
"좋아. 여기에 ___기능을 추가해줘."

만약 이해가 안 된다면:
"이 코드가 어떻게 작동하는지 간단히 설명해줘."

만약 오류가 난다면:
"___오류가 나는데, 고쳐줄 수 있어?"
```

중요한 것은 코드를 완벽하게 이해하는 것이 아니라, **여러분의 의도를 명확히 전달하고 원하는 결과를 얻는 것**입니다. 바이브 코딩의 핵심은 바로 이것입니다.

### 4대 원리 통합의 핵심

마지막으로 4대 원리가 어떻게 함께 작동하는지 정리하겠습니다:

**1. 분해로 시작합니다**
- 큰 문제를 작은 단계로 나눕니다
- 각 단계는 관리하기 쉬운 크기여야 합니다

**2. 패턴으로 효율을 높입니다**
- 반복되는 것을 찾아 규칙으로 만듭니다
- 한 번 만든 규칙을 여러 곳에 적용합니다

**3. 추상화로 단순하게 만듭니다**
- 각 단계에서 핵심만 남깁니다
- 복잡한 세부사항은 숨깁니다

**4. 알고리즘으로 실행 가능하게 만듭니다**
- 추상화된 단계들을 구체적인 명령으로 바꿉니다
- 순서와 조건을 명확히 합니다

**5. Copilot에게 전달합니다**
- 위의 과정을 자연스러운 언어로 설명합니다
- 명확하고 구체적으로 표현합니다
- 결과를 확인하고 개선합니다

이 과정이 자연스러워질 때까지 연습하세요. 처음에는 의식적으로 4대 원리를 떠올려야 하지만, 점점 자동으로 이렇게 생각하게 될 것입니다.

## 실습 결과 요약

### 이번 주에 배운 것

이번 주 실습을 통해 여러분은 컴퓨팅 사고의 4대 원리를 모두 경험했습니다. 단순히 이론으로 아는 것을 넘어, 실제로 적용하고 GitHub Copilot과 협업하는 방법까지 익혔습니다.

**추상화에서 배운 핵심:**
- 목적에 따라 추상화의 수준이 달라진다는 것
- 좋은 추상화는 본질을 유지하면서 단순하게 만든다는 것
- 무엇을 남기고 무엇을 버릴지 판단하는 방법
- 추상화된 내용을 프롬프트로 표현하는 기술

**알고리즘적 사고에서 배운 핵심:**
- 막연한 과정을 명확한 단계로 정리하는 방법
- 각 단계는 구체적이고 실행 가능해야 한다는 것
- 조건과 선택을 어떻게 표현하는지
- 알고리즘을 자연스러운 언어로 Copilot에게 전달하는 법

**4대 원리 통합에서 배운 핵심:**
- 실제 문제는 하나의 원리만으로 해결되지 않는다는 것
- 분해 → 패턴 인식 → 추상화 → 알고리즘의 흐름이 자연스럽다는 것
- 각 원리가 서로 보완하며 더 나은 해결책을 만든다는 것
- 통합된 사고를 효과적인 프롬프트로 바꾸는 방법

### 실습에서 중요했던 포인트

**1. 스스로 먼저 생각하기**
예시를 보기 전에 여러분이 어떻게 할지 먼저 생각해보는 것이 중요했습니다. 이 과정에서 여러분만의 사고 방식을 발견하고, 예시와 비교하며 배울 수 있었습니다.

**2. 완벽하지 않아도 괜찮다**
처음부터 완벽한 추상화나 알고리즘을 만들 필요는 없습니다. 중요한 것은 시작하는 것이고, GitHub Copilot과의 대화를 통해 점점 개선해나가는 것입니다.

**3. 목적을 항상 기억하기**
"왜 이것을 만드는가?"를 잊지 않으면, 무엇을 추상화하고 어떤 알고리즘을 만들어야 할지 자연스럽게 알 수 있습니다.

**4. 단순함의 가치**
복잡한 것보다 단순한 것이 더 낫습니다. 처음에는 핵심 기능만 구현하고, 필요하면 나중에 추가하는 것이 효과적입니다.

### 앞으로 연습할 방법

이번 주 배운 것을 계속 연마하기 위한 방법들입니다:

**일상 속 연습:**
- 아침 루틴, 저녁 요리, 주말 계획처럼 일상적인 활동을 알고리즘으로 정리해보세요
- 복잡한 설명을 들었을 때 핵심만 추상화해서 요약해보세요
- 반복되는 패턴을 발견하면 메모해두세요

**작은 프로그램 만들기:**
- 실생활의 작은 불편함을 발견하면 GitHub Copilot과 해결해보세요
- 완벽하지 않아도 괜찮습니다. 시도 자체가 연습입니다
- 예: 간단한 메모장, 날씨 알림, 운동 기록 등

**프롬프트 작성 연습:**
- 뉴스 기사나 레시피를 읽고 GitHub Copilot에게 전달할 프롬프트로 바꿔보세요
- 처음에는 길게 써도 좋습니다. 점점 간결하게 만들어보세요
- 같은 내용을 다른 방식으로 표현해보며 어떤 것이 더 효과적인지 비교하세요

**반복적 개선 연습:**
- 한 번에 완벽한 프롬프트를 만들려 하지 마세요
- 기본적인 프롬프트로 시작해서 GitHub Copilot과 대화하며 개선하세요
- "더 간단하게", "이 기능 추가해줘" 같은 점진적 요청을 연습하세요

### 다음 주 준비

다음 주는 **중간평가와 4대 원리 종합 연습**입니다. 지금까지 배운 모든 것을 복습하고 통합하는 시간입니다.

**준비할 것:**
- 이번 주까지 실습한 내용 중 어려웠던 부분 정리하기
- 4대 원리를 각각 한 문장으로 설명할 수 있는지 확인하기
- 실생활에서 해결하고 싶은 작은 문제 하나 생각해오기

**복습하면 좋은 것:**
- 7주차: 분해와 패턴 인식의 기본 개념
- 8주차: 추상화와 알고리즘의 실전 적용
- 6주차: GitHub Copilot과 효과적으로 대화하는 방법

### 스스로 점검하기

다음 질문에 답해보세요. 편안하게 답할 수 있다면 잘 이해한 것입니다:

**추상화 체크:**
- 복잡한 내용을 누군가에게 설명할 때, 핵심만 간추려 말할 수 있나요?
- 같은 내용을 목적에 따라 다르게 설명할 수 있나요?
- 무엇이 중요한 정보이고 무엇이 부가적인지 구분할 수 있나요?

**알고리즘 체크:**
- 일상적인 과정을 단계별로 설명할 수 있나요?
- 각 단계가 명확하고 실행 가능한가요?
- "만약...이라면" 같은 조건을 포함할 수 있나요?

**통합 사고 체크:**
- 문제를 보면 자연스럽게 "어떻게 나눌까?" 생각이 드나요?
- 패턴을 발견하고 활용하려는 습관이 생겼나요?
- GitHub Copilot에게 무엇을 어떻게 설명해야 할지 감이 오나요?

모든 질문에 "그렇다"고 답하지 못해도 괜찮습니다. 지금은 연습 중이고, 계속 나아지고 있습니다.

### 마무리하며

추상화와 알고리즘적 사고는 처음에는 어색하게 느껴질 수 있습니다. "이렇게까지 자세히 생각해야 하나?" 싶을 수도 있습니다. 하지만 이것이 바로 컴퓨팅 사고의 핵심입니다.

여러분이 막연하게 "이렇게 하면 되겠지"라고 생각하던 것을 명확한 단계로 정리하고, 복잡한 것에서 핵심을 추출하는 연습을 했습니다. 이 능력은 프로그래밍뿐만 아니라 모든 문제 해결에 도움이 됩니다.

GitHub Copilot은 여러분의 생각을 코드로 바꿔주는 도구입니다. 하지만 그 생각 자체는 여러분이 만들어야 합니다. 이번 주 실습을 통해 여러분은 그 생각을 만드는 방법을, 그리고 그것을 효과적으로 전달하는 방법을 배웠습니다.

---

### 다음 주 예고: 중간평가와 종합 연습

다음 주는 지금까지 배운 4대 원리를 모두 활용하는 중간평가 주간입니다:
- 컴퓨팅 사고 4대 원리를 하나의 문제에 통합 적용
- 실제 문제를 처음부터 끝까지 혼자 해결하는 연습
- 지금까지의 학습 내용 점검 및 보완

미리 생각해볼 것:
- 일상에서 바이브 코딩으로 해결하고 싶은 간단한 문제 찾아보기
- 그 문제를 4대 원리로 어떻게 분석할지 생각해보기

다음 주 중간평가에서 만나요. 지금까지 정말 잘하고 계십니다!

// 이미지로 교체되어야 함 : 4대 원리가 순환하며 통합되는 모습을 보여주는 다이어그램
프롬프트: Create a circular diagram showing the four computational thinking principles (Decomposition, Pattern Recognition, Abstraction, Algorithmic Thinking) connected in a cycle with arrows. Each principle should be represented by an icon and connected to the others, showing how they work together. Use warm, friendly colors like soft blues and oranges. The style should be modern, simple, and educational, suitable for a beginner's textbook. Add "GitHub Copilot" at the center to show it receives input from all four principles.
