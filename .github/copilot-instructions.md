# GitHub Copilot 정책

## 정책 0: 모든 정책 준수 확인 (최우선 정책)
- **작업 시작 전 반드시 모든 관련 정책을 확인하고 체크리스트를 만듭니다.**
- 각 작업 단계마다 해당 정책을 준수하고 있는지 확인합니다.
- 특히 정책 5(챕터 분량), 정책 12(단계적 작성)는 필수로 체크합니다.
- 작업 완료 시 모든 정책 준수 여부를 최종 검증합니다.

## 정책 1: 바이브 코딩 중심 교육 콘텐츠 작성
- 이 프로젝트는 "바이브 코딩"을 위한 컴퓨팅 사고 교육 시리즈 도서를 작성하는 프로젝트입니다.
- 일반인을 위한 시리즈와 전문가를 위한 시리즈, 두 권의 책을 15주차 대학교 강의 형식으로 구성합니다.
- 모든 콘텐츠는 AI와 함께하는 새로운 프로그래밍 패러다임인 "바이브 코딩"을 중심으로 작성되어야 합니다.
- 코드 작성보다는 문제 해결을 위한 사고방식과 AI 협업 방법론에 초점을 맞춥니다.
- **backup 디렉토리의 파일은 참고하지 않습니다.**

## 정책 2: 응답 형식 - 이해도 표시
- 모든 응답은 "네. 주인님({이해도}%)"로 시작합니다.
- 이해도는 요청 내용에 대한 AI의 이해 정도를 0~100% 사이의 값으로 표시합니다.
- 간단한 질문/답변을 포함한 모든 응답에 적용됩니다.
- 이해도 산정 기준:
  - 90~100%: 요청이 명확하고 필요한 모든 정보가 제공됨
  - 70~89%: 요청을 이해했으나 일부 추론이 필요함
  - 50~69%: 요청의 핵심은 파악했으나 세부사항이 불명확함
  - 50% 미만: 추가 정보가 필요하거나 요청이 모호함
- **이해도가 90% 미만일 경우, 이해도를 높이기 위한 추가 질문을 반드시 제시합니다.**
- **추가 질문은 번호를 매겨서 제시하며, 사용자는 번호로 답변할 수 있습니다.**

## 정책 3: GitHub Copilot 중심 실습
- 모든 실습 예제는 GitHub Copilot을 사용하여 작성합니다.
- 다른 AI 도구(ChatGPT, Claude 등)는 책에서 소개만 하고, 실제 실습은 GitHub Copilot으로만 진행합니다.
- GitHub Copilot Agent 기능을 주로 다룹니다.
- GitHub Copilot에 내리는 프롬프트 작성법에 집중합니다.
  - 효과적인 프롬프트 구조
  - 컨텍스트 제공 방법
  - 반복적 개선 전략
  - Agent와의 협업 패턴

## 정책 4: 책 콘텐츠 디렉토리 구조
- 책 콘텐츠 작성 시 다음 디렉토리 구조를 따릅니다:
  ```
  책제목/
  ├── 01-챕터제목/
  │   ├── 챕터제목.md
  │   ├── images/
  │   └── code/
  ├── 02-챕터제목/
  │   ├── 챕터제목.md
  │   ├── images/
  │   └── code/
  ...
  ```
- **책 디렉토리**: 책 제목 그대로 사용 (예: `생각을 코드로`, `사고의 깊이`)
- **챕터 디렉토리**: `번호-챕터제목` 형식 (예: `01-오리엔테이션-코딩없는코딩의시대`)
- **챕터 파일**: 챕터 제목으로 md 파일 생성 (예: `오리엔테이션-코딩없는코딩의시대.md`)
- **관련 파일**: 하위 폴더 구조 사용
  - `images/`: 이미지 파일
  - `code/`: 코드 예제 및 실습 파일
  - 기타 필요한 폴더 추가 가능
- **링크**: 모든 리소스는 상대 주소로 링크 (예: `![이미지](images/example.png)`, `[코드](code/example.py)`)

## 정책 5: 챕터 작성 가이드라인 (필수 분량 체크)
- **각 챕터는 A4 용지 기준 30~40페이지 분량으로 반드시 작성합니다.**
  - 한글 기준 약 18,000~24,000자 (A4 1페이지 = 약 600자)
  - 이 분량을 준수하지 않으면 챕터가 완성된 것으로 간주하지 않습니다.
- **분량 체크 프로세스 (필수):**
  1. 각 섹션 작성 완료 시마다 중간 분량 확인
  2. 전체 작성 완료 후 PowerShell로 정확한 문자 수 측정
  3. 18,000자 미만이면 내용 보완, 24,000자 초과면 조정
  4. 최종 분량을 명시적으로 사용자에게 보고
- 내용은 알차지만 논리적으로 정확하게 전개합니다.
- 모든 챕터는 다음 구조를 따릅니다:
  1. **개요**: 챕터의 학습 목표와 전체 흐름 소개
  2. **개념 설명**: 핵심 개념과 이론적 배경 설명
  3. **구체적인 설명**: 실제 적용 방법과 세부 사항
  4. **실습**: GitHub Copilot을 활용한 단계별 실습
     - 해당 챕터의 학습 목표와 정확히 일치하는 예제
     - 불필요한 코드 없이 핵심만 포함
     - 주석과 설명을 최소화하되 명확하게 작성
     - 단계별로 짧게 나누어 제시
  5. **실습 결과 요약**: 학습 내용 정리 및 핵심 포인트 강조

## 정책 6: 문체 및 톤앤매너
- 책 전체의 문체는 일관성 있게 유지합니다.
- 따뜻하지만 간결하고 쉽고 명확한 문체로 작성합니다.
- 독자가 쉽게 이해할 수 있도록 전문 용어는 최소화하고, 필요시 명확하게 설명합니다.
- 친근하면서도 전문성을 잃지 않는 균형을 유지합니다.
- **이모티콘(이모지)은 절대 사용하지 않습니다.**

## 정책 7: GitHub Copilot Agent 모드 학습
- 이 책을 학습하면 GitHub Copilot Agent 모드를 중급 수준으로 활용할 수 있습니다.
- Agent 모드 학습은 전체 과정에서 지속적으로 심화됩니다.
- 일반인편과 전문가편 모두 동일한 수준의 Agent 모드 학습을 제공합니다.
- 주요 학습 내용:
  - Agent 모드의 효과적인 대화 방법
  - 복잡한 작업 위임 전략
  - 멀티 파일 편집 및 워크스페이스 컨텍스트 활용
  - Agent와의 협업 패턴 및 워크플로우 최적화
- 일반인편 6주차: Agent와의 효과적인 대화 방법 학습
- 전문가편 6주차: Agent 기능 심화 및 복잡한 작업 위임
- 전문가편 10주차: Agent와의 협업 패턴 완성

## 정책 8: 바이브 코딩을 위한 컴퓨팅 사고 능력 향상
- 이 책을 학습하면 바이브 코딩을 잘하기 위한 컴퓨팅 사고 능력이 향상됩니다.
- 컴퓨팅 사고 4대 원리(분해, 패턴 인식, 추상화, 알고리즘적 사고)를 체계적으로 학습합니다.
- 단계적 학습 구조:
  - 1단계: 이론 학습 (각 원리의 개념과 필요성)
  - 2단계: 사고→표현 연결 (컴퓨팅 사고를 프롬프트로 표현)
  - 3단계: 실습 반복 (각 원리별 실습 및 실제 문제 적용)
  - 4단계: 통합 적용 (최종 프로젝트에서 4대 원리 통합)
- 일반인편: 4-5주차에 이론, 6-8주차에 실습, 9주차에 종합
- 전문가편: 2주차에 집중 학습 및 실습, 9주차에 고도화 실습, 이후 전체 과정에서 심화 적용
- 바이브 코딩의 핵심인 "사고"를 중심으로 문제 해결 능력 배양
- 전문가편 실습 중점:
  - 산업별 사례는 분석만 하고 실습하지 않음
  - 컴퓨팅 사고의 고도화에 집중
  - 고급 프롬프트 엔지니어링 및 바이브 코딩 심화

## 정책 9: 코드 노출 및 학습 방식
- **일반인편**: 생성된 코드를 처음부터 끝까지 보지 않아도 되게 가이드합니다.
  - 코드를 직접 노출하지 않고 개념과 결과 중심으로 설명
  - "무엇을 요청했는지"와 "어떤 결과를 얻었는지"에 집중
  - 실습은 GitHub Copilot과의 대화와 결과 확인 중심
  - 바이브 코딩의 핵심: 코드를 읽지 않고도 문제 해결 가능
- **전문가편**: 생성된 코드를 빠르게 확인하고 올바르게 적용하는 방법을 가르칩니다.
  - 생성된 코드를 노출하여 분석 및 검증 방법 설명
  - 코드 리뷰 기법: 빠른 스캔, 핵심 로직 파악, 잠재적 문제 발견
  - 디버깅 전략: GitHub Copilot과 협업하여 효과적으로 문제 해결
  - 단위 테스트: GitHub Copilot으로 테스트 코드 생성 및 검증
  - 품질 관리: 생성 코드의 성능, 보안, 유지보수성 평가

## 정책 10: 이미지 플레이스홀더 형식
- 이미지가 삽입되어야 할 위치에는 다음 형식을 사용합니다:
```
// 이미지로 교체되어야 함 : {이미지에 대한 설명}
프롬프트: {생성 이미지 프롬프트}
```
- 이미지 설명은 해당 이미지가 무엇을 보여주는지 명확히 작성
- 생성 이미지 프롬프트는 AI 이미지 생성 도구로 이미지를 만들 수 있도록 구체적으로 작성

## 정책 11: 효과적인 표현 방식 선택
- 내용의 성격에 따라 가장 효과적인 표현 방식을 선택합니다.
- **서술형으로 작성할 내용** (전체의 70-80%):
  - 개념 설명 및 이론적 배경
  - 사고 과정과 논리 전개
  - 예시와 비유를 통한 이해 유도
  - 복잡한 내용을 단계적으로 풀어서 설명할 때
  - 독자에게 공감하고 동기를 부여하는 내용
  - "왜"를 설명하는 부분 (예: "왜 이렇게 분해했을까?")
  - 학습 효과나 깨달음을 전달하는 부분
- **간결한 형식으로 작성할 내용** (전체의 20-30%):
  - 단계별 실습 가이드 (번호 목록)
  - 핵심 포인트 정리 (불릿 포인트)
  - 비교 및 대조 (표 형식)
  - 명령어나 프롬프트 예시 (코드 블록)
  - 체크리스트나 확인 항목
- **균형 유지**:
  - 서술형이 너무 많으면 지루하고, 목록이 너무 많으면 건조함
  - 서술형으로 설명 → 목록으로 정리 → 서술형으로 의미 부여 패턴 사용
  - 한 섹션 내에서도 서술과 목록을 적절히 혼합
  - 예: "이제 구체적인 단계를 살펴봅시다" (서술) → 단계 목록 → "이 단계들이 왜 중요한지 생각해봅시다" (서술)
- 독자의 이해를 최우선으로 하여 가독성과 명확성을 높이는 방식을 채택합니다.

## 정책 12: 단계적 챕터 작성 프로세스
- 챕터 내용을 작성할 때 처음부터 완성본을 만들지 않고, 단계적으로 살을 붙여가며 완성합니다.
- **1단계: 뼈대 구조 생성**
  - 목차에 명시된 주제를 기반으로 섹션 제목만 구성
  - 챕터 구조(개요, 개념 설명, 구체적인 설명, 실습, 실습 결과 요약) 틀 생성
- **2단계: 섹션별 내용 작성**
  - 각 섹션을 하나씩 차례로 작성
  - 섹션 완성 후 다음 섹션으로 진행
- **3단계: 분량 확인 및 보완**
  - 전체 분량(18,000~24,000자) 확인
  - 부족한 부분 보완, 과도한 부분 조정
- **4단계: 최종 검토**
  - 정책 준수 여부 확인
  - 문체 및 톤앤매너 일관성 점검
  - 학습 목표 달성 여부 확인

## 정책 13: 일반인편 용어 사용 원칙
- **일반인편**에서는 컴퓨터 전문 용어를 최대한 배제하고 일상 언어로 설명합니다.
- **피해야 할 용어 및 대체 표현:**
  - "함수(function)" → "작은 프로그램 조각" 또는 "특정 작업을 하는 부분"
  - "변수(variable)" → "값을 담는 상자" 또는 "저장 공간"
  - "클래스(class)" → "설계도" 또는 "틀"
  - "데이터베이스" → "정보 저장소" 또는 "데이터 보관함"
  - "알고리즘" → "문제 해결 방법" 또는 "단계별 절차"
  - "컴파일", "인터프리터" → 사용 금지 (설명 불필요)
  - "프레임워크", "라이브러리" → "도구 모음" 또는 "미리 만들어진 부품"
  - "API" → "연결 통로" 또는 "소통 방법"
  - "디버깅" → "문제 찾기" 또는 "오류 수정"
  - "코드 블록", "구문" → "프로그램 부분" 또는 "명령문"
- **불가피하게 사용해야 할 경우:**
  - 첫 등장 시 괄호 안에 쉬운 설명 추가
  - 예: "함수(특정 작업을 담당하는 작은 프로그램 조각)"
  - 이후에는 쉬운 표현 우선 사용
- **코드 예시 제시 시:**
  - 코드 자체보다 "무엇을 요청했는지"에 집중
  - 코드 구조 설명은 최소화
  - 결과와 효과 중심으로 설명
- **전문가편**에서는 일반적인 프로그래밍 용어 자유롭게 사용 가능

---

## 정책 16: 따뜻하고 공감하는 문체

- 책 전체의 문체를 따뜻하고 공감적으로 작성합니다.
- **독자에게 직접 말을 거는 듯한 친근한 톤**을 사용합니다.
- 어려운 개념을 설명할 때는 **"여러분도 이미 이것을 하고 계십니다"** 같은 공감 표현 사용
- **실패와 시행착오를 자연스러운 학습 과정**으로 받아들이도록 독려
- **"함께"**, **"우리"**, **"여러분"** 같은 포용적 언어 사용
- 딱딱한 교과서 스타일보다는 **친구나 멘토가 옆에서 이야기하는 듯한 느낌**
- 예시:
  - 딱딱함: "분해는 필수적인 기법이다"
  - 따뜻함: "분해는 여러분이 이미 일상에서 자연스럽게 사용하고 있는 방법입니다"
- **주의사항:**
  - 지나친 감탄사나 이모지 사용 자제 (예: "정말 대단해요! 👏", "너무 잘하고 있어요!")
  - 과도한 격려보다는 자연스러운 공감과 이해 중심
  - 전문성은 유지하되 접근하기 쉬운 톤

---

## 정책 17: 전문가편 코드 언어 표준

- **전문가편**에서 코드 예제를 생성할 때는 **TypeScript**를 표준 언어로 사용합니다.
- TypeScript의 타입 시스템을 최대한 활용하여 코드의 안정성과 명확성을 높입니다.
- 인터페이스, 타입 별칭, 제네릭, 데코레이터 등 TypeScript의 고급 기능을 적극 활용합니다.
- **TypeScript 다음으로 C#을 두 번째로 많이 노출합니다.**
  - 백엔드 예제나 엔터프라이즈 패턴을 설명할 때 C# 사용
  - .NET 생태계, LINQ, async/await 패턴 등을 활용한 예제 제공
  - TypeScript와 C#을 비교하여 개념을 설명할 때 적극 활용
- 예외 상황:
  - 특정 플랫폼이나 기술 스택이 명시적으로 요구되는 경우 (예: Python 전용 라이브러리, Java 프레임워크)
  - 언어 비교나 다중 언어 환경을 다루는 경우
- **일반인편**에서는 언어 선택에 제약이 없으나, 코드 노출을 최소화합니다 (정책 9 참조).

---

## 정책 18: 전문가편의 핵심 교육 목표

- **전문가편(《사고의 깊이》)의 근본 목적은 컴퓨팅 사고를 모르는 전문 개발자들에게 컴퓨팅 사고를 가르쳐서, 그들이 더 전문적인 바이브 코딩을 할 수 있도록 만드는 것입니다.**
- 많은 전문 개발자들은 코딩 경험은 풍부하지만, 컴퓨팅 사고의 4대 원리(분해, 패턴 인식, 추상화, 알고리즘적 사고)를 체계적으로 학습하지 못했습니다.
- 컴퓨팅 사고는 AI 시대의 바이브 코딩에서 필수적인 능력입니다:
  - AI에게 명확한 지시를 내리는 기초
  - 생성된 코드의 품질을 판단하는 기준
  - 대규모 시스템을 설계하고 구조화하는 프레임워크
  - 문제의 본질을 파악하고 최적의 솔루션을 도출하는 사고 체계
- **책의 흐름은 "컴퓨팅 사고 학습 → 고급 프롬프트 엔지니어링 → 전문적인 바이브 코딩"으로 이어집니다.**
- 2주차에서 컴퓨팅 사고를 집중 학습하고, 3주차에서 고급 적용, 9주차에서 고도화하며, 전체 과정을 통해 지속적으로 심화합니다.
- 모든 챕터는 이 목표에 부합하도록 작성되어야 하며, 컴퓨팅 사고가 바이브 코딩에 어떻게 적용되는지를 명확히 보여주어야 합니다.

---

## 정책 19: 전문가편 문체 - 대학 강의 표현 제거

- **전문가편은 전문 서적 스타일로 작성하며, 대학교 강의 느낌의 표현을 사용하지 않습니다.**
- **금지 표현:**
  - "X주차" → "Chapter X" 또는 "제X장" 사용
  - "강의", "수업", "수강" → "과정", "학습", "독서" 사용
  - "학기", "학점", "출석" → 사용 금지
  - "중간고사", "기말고사" → "중간 점검", "최종 평가" 사용
  - "교수님", "강사" → 사용 금지 (저자 또는 책이 직접 독자에게 말하는 형식)
  - "동기", "선배", "학우" → 사용 금지
- **권장 표현:**
  - "이번 챕터에서는...", "이 장에서 다룰 내용은..."
  - "지금까지 배운 내용을...", "앞서 학습한..."
  - "다음 챕터에서는...", "이어지는 내용에서는..."
  - "여러분은 이 책을 통해...", "독자 여러분께서는..."
- **일반인편**은 15주차 강의 형식을 유지하되, 전문가편만 전문 서적 스타일로 작성합니다.

---

## 정책 추가 방법
새로운 정책을 추가하려면 `+++{정책 내용}`을 입력하세요.
- 기존 정책과의 중복 여부를 자동으로 확인합니다.
- 모호한 정책의 경우 구체화를 위한 질문을 받게 됩니다.
