# Chapter 8. 바이브 코딩의 실전 적용 전략

**난이도: 🟡 중급**

## 개요

지금까지 7개 챕터에서 바이브 코딩의 이론과 기법을 체계적으로 학습했습니다. 이제 그 지식을 실전에 적용할 시간입니다. 이번 챕터에서는 실무에서 즉시 활용할 수 있는 세 가지 핵심 전략을 다룹니다.

실무 환경은 항상 이상적이지 않습니다. 레거시 코드베이스, 부족한 테스트, 복잡한 배포 프로세스 등 다양한 제약이 존재합니다. 이번 챕터에서는 GitHub Copilot을 활용하여 이러한 현실적 문제를 효과적으로 해결하는 방법을 배웁니다.

### 이번 챕터에서 다룰 내용

**1. 레거시 시스템 현대화**
오래된 코드베이스를 현대적인 아키텍처로 점진적으로 변환하는 전략입니다. GitHub Copilot은 다음을 돕습니다:
- 레거시 코드 이해 및 문서화
- 안전한 리팩토링 경로 제시
- 테스트 커버리지 점진적 확보
- 새로운 패턴 적용

**2. 테스트 자동화**
품질을 보장하면서도 개발 속도를 유지하는 핵심은 자동화된 테스트입니다. GitHub Copilot으로:
- 단위 테스트 자동 생성
- 통합 테스트 시나리오 설계
- 엣지 케이스 발견 및 테스트
- 테스트 유지보수 간소화

**3. CI/CD 파이프라인 구축**
코드가 배포되기까지의 전체 흐름을 자동화합니다:
- GitHub Actions/Azure DevOps 파이프라인 설계
- 빌드, 테스트, 배포 자동화
- 환경별 배포 전략
- 롤백 및 모니터링

### 학습 목표

이번 챕터를 마치면 다음을 할 수 있게 됩니다:
- 레거시 프로젝트를 GitHub Copilot과 함께 체계적으로 개선
- 테스트 주도 개발(TDD)을 바이브 코딩과 결합
- 전체 소프트웨어 개발 생명주기를 AI와 협업하여 최적화
- 실무 프로젝트에 즉시 적용 가능한 자동화 파이프라인 구축

이번 챕터는 특히 실습 중심입니다. 이론보다는 "어떻게 하는가"에 집중하며, 실제로 따라 할 수 있는 구체적인 단계를 제시합니다.

## 1. GitHub Copilot으로 레거시 시스템 현대화

레거시 코드베이스를 마주하면 막막합니다. 문서는 부족하고, 테스트는 없으며, 아키텍처는 복잡하게 얽혀있습니다. GitHub Copilot은 이러한 레거시 현대화 작업을 체계적으로 도와줄 수 있는 강력한 파트너입니다.

### 코드 분석 및 이해

첫 번째 단계는 레거시 코드를 이해하는 것입니다. GitHub Copilot은 코드 분석과 문서화를 도와줍니다.

**Step 1: 코드 베이스 구조 파악**

```
"이 프로젝트의 전체 구조를 분석해줘.
주요 디렉토리와 파일들의 역할을 설명해줘."
```

Agent는 프로젝트를 스캔하고 다음과 같은 분석을 제공합니다:
- 주요 진입점(entry points)
- 핵심 비즈니스 로직 위치
- 외부 의존성
- 아키텍처 패턴(MVC, 레이어드 등)

**Step 2: 복잡한 함수 이해**

레거시 코드에서 가장 어려운 부분은 복잡하게 얽힌 로직입니다.

```typescript
// 레거시 코드 예시: 200줄짜리 복잡한 함수
function processOrder(order: any) {
  // 복잡한 로직 200줄...
  // 여러 가지 일을 한 함수에서 처리
  // 주석도 없고 변수명도 모호함
}
```

GitHub Copilot에게 분석을 요청합니다:

```
"이 processOrder 함수가 무엇을 하는지 분석하고,
단계별로 설명해줘. 각 단계의 책임도 명시해줘."
```

Agent의 분석 결과:
```
이 함수는 다음을 수행합니다:
1. 주문 검증 (1-30줄)
2. 재고 확인 및 예약 (31-70줄)
3. 결제 처리 (71-120줄)
4. 배송 준비 (121-160줄)
5. 알림 발송 (161-200줄)

문제점:
- 단일 책임 원칙 위반
- 테스트 불가능
- 에러 처리 부족
```

**Step 3: 의존성 파악**

```
"이 모듈의 의존성 그래프를 그려줘.
어떤 모듈이 어떤 모듈에 의존하는지 보여줘."
```

// 이미지로 교체되어야 함 : 레거시 코드의 복잡한 의존성 그래프를 단순화하는 과정 - 왼쪽에 엉킨 스파게티 코드, 오른쪽에 깔끔한 계층 구조
프롬프트: A before-and-after comparison diagram showing legacy code modernization: Left side shows tangled spaghetti code with messy arrows between modules in red/gray, right side shows clean layered architecture with organized components and clear unidirectional dependencies in green/blue, middle has arrow labeled "GitHub Copilot Refactoring", professional technical diagram style

### 점진적 리팩토링 전략

레거시 시스템은 한 번에 바꿀 수 없습니다. 점진적 접근이 핵심입니다.

**Strangler Fig 패턴**

새로운 코드로 레거시를 서서히 대체합니다.

```
"processOrder 함수를 Strangler Fig 패턴으로 리팩토링하고 싶어.
먼저 OrderValidator를 새로운 클래스로 추출해줘.
기존 함수는 그대로 두고 새 클래스를 호출하도록 수정해줘."
```

TypeScript로 구현:

```typescript
// 1단계: 검증 로직을 새로운 클래스로 추출
class OrderValidator {
  validate(order: Order): ValidationResult {
    const errors: string[] = [];
    
    if (!order.customerId) {
      errors.push('고객 ID는 필수입니다');
    }
    
    if (!order.items || order.items.length === 0) {
      errors.push('주문 항목이 없습니다');
    }
    
    if (order.totalAmount <= 0) {
      errors.push('주문 금액은 0보다 커야 합니다');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// 2단계: 레거시 함수에서 새 클래스 사용
function processOrder(order: any) {
  // 새로운 검증 로직 사용
  const validator = new OrderValidator();
  const validationResult = validator.validate(order);
  
  if (!validationResult.isValid) {
    throw new Error(validationResult.errors.join(', '));
  }
  
  // 나머지 레거시 로직은 그대로...
  // (나중에 점진적으로 교체)
}
```

**단계별 분리 전략**

복잡한 함수를 단계적으로 분리합니다:

```
"이제 결제 처리 부분도 PaymentService로 추출해줘.
트랜잭션 처리도 추가하고."
```

```typescript
interface IPaymentService {
  charge(order: Order, paymentMethod: PaymentMethod): Promise<PaymentResult>;
}

class PaymentService implements IPaymentService {
  constructor(
    private paymentGateway: IPaymentGateway,
    private logger: ILogger
  ) {}
  
  async charge(order: Order, paymentMethod: PaymentMethod): Promise<PaymentResult> {
    this.logger.info('Payment processing started', { orderId: order.id });
    
    try {
      const result = await this.paymentGateway.charge(
        order.totalAmount,
        paymentMethod
      );
      
      this.logger.info('Payment successful', { orderId: order.id });
      return result;
      
    } catch (error) {
      this.logger.error('Payment failed', { orderId: order.id, error });
      throw new PaymentException('결제 처리 실패', error);
    }
  }
}

// 레거시 함수 업데이트
async function processOrder(order: any, paymentMethod: any) {
  const validator = new OrderValidator();
  const validationResult = validator.validate(order);
  
  if (!validationResult.isValid) {
    throw new Error(validationResult.errors.join(', '));
  }
  
  // 새로운 결제 서비스 사용
  const paymentService = new PaymentService(paymentGateway, logger);
  const paymentResult = await paymentService.charge(order, paymentMethod);
  
  // 나머지 레거시 로직...
}
```

### 테스트 커버리지 확보

리팩토링의 안전망은 테스트입니다.

**레거시 코드에 테스트 추가**

```
"processOrder 함수의 현재 동작을 보장하는 
캐릭터라이제이션 테스트(Characterization Test)를 작성해줘."
```

```typescript
describe('processOrder - Legacy Behavior', () => {
  it('should process valid order successfully', async () => {
    // 기존 동작을 그대로 테스트
    const order = createValidOrder();
    const result = await processOrder(order, paymentMethod);
    
    expect(result.status).toBe('completed');
    expect(result.orderId).toBeDefined();
  });
  
  it('should throw error for invalid order', async () => {
    const invalidOrder = { ...createValidOrder(), items: [] };
    
    await expect(processOrder(invalidOrder, paymentMethod))
      .rejects.toThrow('주문 항목이 없습니다');
  });
});
```

**리팩토링된 코드 테스트**

```
"OrderValidator와 PaymentService의 단위 테스트를 작성해줘."
```

```typescript
describe('OrderValidator', () => {
  let validator: OrderValidator;
  
  beforeEach(() => {
    validator = new OrderValidator();
  });
  
  it('should validate correct order', () => {
    const order = createValidOrder();
    const result = validator.validate(order);
    
    expect(result.isValid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });
  
  it('should reject order without customer', () => {
    const order = { ...createValidOrder(), customerId: null };
    const result = validator.validate(order);
    
    expect(result.isValid).toBe(false);
    expect(result.errors).toContain('고객 ID는 필수입니다');
  });
});

describe('PaymentService', () => {
  let paymentService: PaymentService;
  let mockGateway: jest.Mocked<IPaymentGateway>;
  let mockLogger: jest.Mocked<ILogger>;
  
  beforeEach(() => {
    mockGateway = {
      charge: jest.fn()
    } as any;
    
    mockLogger = {
      info: jest.fn(),
      error: jest.fn()
    } as any;
    
    paymentService = new PaymentService(mockGateway, mockLogger);
  });
  
  it('should charge payment successfully', async () => {
    const order = createValidOrder();
    const paymentMethod = createPaymentMethod();
    
    mockGateway.charge.mockResolvedValue({
      success: true,
      transactionId: 'tx-123'
    });
    
    const result = await paymentService.charge(order, paymentMethod);
    
    expect(result.success).toBe(true);
    expect(mockGateway.charge).toHaveBeenCalledWith(
      order.totalAmount,
      paymentMethod
    );
    expect(mockLogger.info).toHaveBeenCalledWith(
      'Payment successful',
      expect.any(Object)
    );
  });
});
```

### C# 레거시 현대화 예제

.NET Framework 레거시를 .NET 8으로 마이그레이션하는 시나리오:

```
"이 .NET Framework 4.7 코드를 .NET 8로 마이그레이션하고 싶어.
현대적 패턴(async/await, DI, minimal APIs)을 적용해줘."
```

```csharp
// 레거시: .NET Framework 4.7
public class OrderService
{
    public void ProcessOrder(int orderId)
    {
        using (var connection = new SqlConnection(ConfigurationManager.ConnectionStrings["Default"].ConnectionString))
        {
            connection.Open();
            var command = new SqlCommand("SELECT * FROM Orders WHERE Id = @Id", connection);
            command.Parameters.AddWithValue("@Id", orderId);
            
            var reader = command.ExecuteReader();
            // 동기 처리...
        }
    }
}

// 현대화: .NET 8
public interface IOrderRepository
{
    Task<Order?> GetByIdAsync(int orderId, CancellationToken cancellationToken = default);
    Task SaveAsync(Order order, CancellationToken cancellationToken = default);
}

public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    
    public OrderRepository(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task<Order?> GetByIdAsync(int orderId, CancellationToken cancellationToken = default)
    {
        return await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.Id == orderId, cancellationToken);
    }
    
    public async Task SaveAsync(Order order, CancellationToken cancellationToken = default)
    {
        _context.Orders.Update(order);
        await _context.SaveChangesAsync(cancellationToken);
    }
}

public class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly ILogger<OrderService> _logger;
    
    public OrderService(IOrderRepository repository, ILogger<OrderService> logger)
    {
        _repository = repository;
        _logger = logger;
    }
    
    public async Task ProcessOrderAsync(int orderId, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Processing order {OrderId}", orderId);
        
        var order = await _repository.GetByIdAsync(orderId, cancellationToken);
        
        if (order == null)
        {
            throw new NotFoundException($"Order {orderId} not found");
        }
        
        // 비즈니스 로직...
        order.Process();
        
        await _repository.SaveAsync(order, cancellationToken);
        
        _logger.LogInformation("Order {OrderId} processed successfully", orderId);
    }
}

// Program.cs (Minimal API)
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default")));

builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<OrderService>();

var app = builder.Build();

app.MapPost("/orders/{id}/process", async (
    int id,
    OrderService service,
    CancellationToken cancellationToken) =>
{
    await service.ProcessOrderAsync(id, cancellationToken);
    return Results.Ok();
});

app.Run();
```

### 실전 리팩토링 체크리스트

레거시 현대화 작업 시 다음을 확인하세요:

**분석 단계**
- [ ] 전체 코드베이스 구조 파악
- [ ] 핵심 비즈니스 로직 식별
- [ ] 의존성 그래프 작성
- [ ] 테스트 커버리지 현황 확인

**계획 단계**
- [ ] 우선순위 결정 (어디서부터 시작?)
- [ ] 리팩토링 전략 선택 (Big Bang vs Strangler Fig)
- [ ] 마일스톤 설정

**실행 단계**
- [ ] 캐릭터라이제이션 테스트 작성
- [ ] 한 번에 하나씩 점진적 리팩토링
- [ ] 각 단계마다 테스트 실행
- [ ] 코드 리뷰 및 검증

**완료 단계**
- [ ] 성능 비교 (전/후)
- [ ] 문서 업데이트
- [ ] 팀 지식 공유

## 2. GitHub Copilot 기반 테스트 자동화

테스트는 코드 품질의 안전망이지만, 작성하기 번거롭습니다. GitHub Copilot은 테스트 작성을 극적으로 간소화하고, 더 포괄적인 테스트 커버리지를 달성하도록 돕습니다.

### 단위 테스트 자동 생성

**기본 테스트 생성**

```
"UserService의 모든 public 메서드에 대한 단위 테스트를 작성해줘.
- 정상 케이스
- 엣지 케이스
- 에러 케이스
모두 포함해서."
```

TypeScript 예제:

```typescript
// UserService.ts
export class UserService {
  constructor(
    private repository: IUserRepository,
    private passwordHasher: IPasswordHasher
  ) {}
  
  async createUser(dto: CreateUserDto): Promise<User> {
    const existing = await this.repository.findByEmail(dto.email);
    if (existing) {
      throw new ConflictException('이미 존재하는 이메일입니다');
    }
    
    const hashedPassword = await this.passwordHasher.hash(dto.password);
    const user = User.create(dto.name, dto.email, hashedPassword);
    
    await this.repository.save(user);
    return user;
  }
}

// UserService.test.ts (GitHub Copilot 생성)
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<IUserRepository>;
  let mockPasswordHasher: jest.Mocked<IPasswordHasher>;
  
  beforeEach(() => {
    mockRepository = {
      findByEmail: jest.fn(),
      save: jest.fn()
    } as any;
    
    mockPasswordHasher = {
      hash: jest.fn()
    } as any;
    
    service = new UserService(mockRepository, mockPasswordHasher);
  });
  
  describe('createUser', () => {
    const validDto: CreateUserDto = {
      name: 'John Doe',
      email: 'john@example.com',
      password: 'SecurePass123!'
    };
    
    // 정상 케이스
    it('should create user successfully', async () => {
      mockRepository.findByEmail.mockResolvedValue(null);
      mockPasswordHasher.hash.mockResolvedValue('hashed_password');
      
      const user = await service.createUser(validDto);
      
      expect(user).toBeDefined();
      expect(user.email).toBe(validDto.email);
      expect(mockRepository.save).toHaveBeenCalledTimes(1);
    });
    
    // 엣지 케이스
    it('should handle email with different cases', async () => {
      mockRepository.findByEmail.mockResolvedValue(null);
      mockPasswordHasher.hash.mockResolvedValue('hashed_password');
      
      const dto = { ...validDto, email: 'JOHN@EXAMPLE.COM' };
      await service.createUser(dto);
      
      expect(mockRepository.findByEmail).toHaveBeenCalledWith('john@example.com');
    });
    
    it('should trim whitespace from name', async () => {
      mockRepository.findByEmail.mockResolvedValue(null);
      mockPasswordHasher.hash.mockResolvedValue('hashed_password');
      
      const dto = { ...validDto, name: '  John Doe  ' };
      const user = await service.createUser(dto);
      
      expect(user.name).toBe('John Doe');
    });
    
    // 에러 케이스
    it('should throw ConflictException when email exists', async () => {
      const existingUser = new User();
      mockRepository.findByEmail.mockResolvedValue(existingUser);
      
      await expect(service.createUser(validDto))
        .rejects.toThrow(ConflictException);
      
      expect(mockRepository.save).not.toHaveBeenCalled();
    });
    
    it('should handle repository errors', async () => {
      mockRepository.findByEmail.mockRejectedValue(new Error('DB Error'));
      
      await expect(service.createUser(validDto))
        .rejects.toThrow('DB Error');
    });
    
    it('should handle password hashing errors', async () => {
      mockRepository.findByEmail.mockResolvedValue(null);
      mockPasswordHasher.hash.mockRejectedValue(new Error('Hashing failed'));
      
      await expect(service.createUser(validDto))
        .rejects.toThrow('Hashing failed');
    });
  });
});
```

### 통합 테스트 시나리오

```
"주문 생성부터 결제 완료까지 전체 플로우를 테스트하는
E2E 테스트를 작성해줘. 실제 DB 사용."
```

```typescript
describe('Order Flow - E2E', () => {
  let app: INestApplication;
  let dbConnection: Connection;
  
  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    
    app = moduleFixture.createNestApplication();
    await app.init();
    
    dbConnection = moduleFixture.get(Connection);
  });
  
  afterAll(async () => {
    await dbConnection.close();
    await app.close();
  });
  
  beforeEach(async () => {
    // 테스트 데이터 초기화
    await dbConnection.query('TRUNCATE TABLE orders CASCADE');
    await dbConnection.query('TRUNCATE TABLE payments CASCADE');
  });
  
  it('should complete order flow successfully', async () => {
    // 1. 사용자 생성
    const userResponse = await request(app.getHttpServer())
      .post('/users')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(201);
    
    const userId = userResponse.body.id;
    
    // 2. 상품 추가
    const productResponse = await request(app.getHttpServer())
      .post('/products')
      .send({
        name: 'Test Product',
        price: 10000,
        stock: 100
      })
      .expect(201);
    
    const productId = productResponse.body.id;
    
    // 3. 주문 생성
    const orderResponse = await request(app.getHttpServer())
      .post('/orders')
      .send({
        customerId: userId,
        items: [
          { productId, quantity: 2 }
        ]
      })
      .expect(201);
    
    const orderId = orderResponse.body.id;
    expect(orderResponse.body.status).toBe('pending');
    expect(orderResponse.body.totalAmount).toBe(20000);
    
    // 4. 결제 처리
    const paymentResponse = await request(app.getHttpServer())
      .post(`/orders/${orderId}/payment`)
      .send({
        method: 'card',
        cardNumber: '1234-5678-9012-3456'
      })
      .expect(200);
    
    expect(paymentResponse.body.status).toBe('completed');
    
    // 5. 주문 상태 확인
    const finalOrderResponse = await request(app.getHttpServer())
      .get(`/orders/${orderId}`)
      .expect(200);
    
    expect(finalOrderResponse.body.status).toBe('paid');
    
    // 6. 재고 감소 확인
    const productCheckResponse = await request(app.getHttpServer())
      .get(`/products/${productId}`)
      .expect(200);
    
    expect(productCheckResponse.body.stock).toBe(98);
  });
  
  it('should rollback on payment failure', async () => {
    // 결제 실패 시 재고 복구 테스트
    const order = await createOrder();
    const initialStock = await getProductStock(order.productId);
    
    await request(app.getHttpServer())
      .post(`/orders/${order.id}/payment`)
      .send({
        method: 'invalid_method'
      })
      .expect(400);
    
    const finalStock = await getProductStock(order.productId);
    expect(finalStock).toBe(initialStock); // 재고 복구 확인
  });
});
```

### 테스트 커버리지 분석

```
"현재 프로젝트의 테스트 커버리지를 분석하고,
커버되지 않은 중요한 부분의 테스트를 생성해줘."
```

GitHub Copilot은 코드 분석 후 다음을 제안합니다:
- 커버리지가 낮은 파일 식별
- 중요한 비즈니스 로직 중 테스트 없는 부분
- 엣지 케이스 테스트 제안

### C# 테스트 자동화

```csharp
// XUnit + Moq를 사용한 C# 테스트
public class OrderServiceTests
{
    private readonly Mock<IOrderRepository> _mockRepository;
    private readonly Mock<IPaymentService> _mockPaymentService;
    private readonly OrderService _service;
    
    public OrderServiceTests()
    {
        _mockRepository = new Mock<IOrderRepository>();
        _mockPaymentService = new Mock<IPaymentService>();
        _service = new OrderService(_mockRepository.Object, _mockPaymentService.Object);
    }
    
    [Fact]
    public async Task ProcessOrder_ValidOrder_ShouldComplete()
    {
        // Arrange
        var order = new Order
        {
            Id = Guid.NewGuid(),
            CustomerId = Guid.NewGuid(),
            TotalAmount = 10000m,
            Status = OrderStatus.Pending
        };
        
        _mockRepository
            .Setup(r => r.GetByIdAsync(order.Id, It.IsAny<CancellationToken>()))
            .ReturnsAsync(order);
        
        _mockPaymentService
            .Setup(p => p.ChargeAsync(It.IsAny<Order>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new PaymentResult { Success = true });
        
        // Act
        await _service.ProcessOrderAsync(order.Id, CancellationToken.None);
        
        // Assert
        Assert.Equal(OrderStatus.Completed, order.Status);
        _mockRepository.Verify(r => r.SaveAsync(order, It.IsAny<CancellationToken>()), Times.Once);
    }
    
    [Theory]
    [InlineData(0)]
    [InlineData(-1000)]
    public async Task ProcessOrder_InvalidAmount_ShouldThrow(decimal amount)
    {
        // Arrange
        var order = new Order { TotalAmount = amount };
        _mockRepository
            .Setup(r => r.GetByIdAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(order);
        
        // Act & Assert
        await Assert.ThrowsAsync<InvalidOperationException>(
            () => _service.ProcessOrderAsync(order.Id, CancellationToken.None));
    }
}
```

// 이미지로 교체되어야 함 : 테스트 자동화 파이프라인 - 코드 작성 → AI가 테스트 생성 → 자동 실행 → 커버리지 리포트 → 피드백 루프
프롬프트: A circular automated testing pipeline diagram: Developer writes code (person at computer) → GitHub Copilot generates tests (AI robot with test tubes) → Tests auto-run (play button with checkmarks) → Coverage report (dashboard with percentage bars) → Feedback loop arrow back to developer, each stage connected with arrows, includes small icons for each step, modern DevOps style, blue and green color scheme

## 3. 지속적 통합/배포(CI/CD) 파이프라인 설계

코드를 작성하는 것만큼 중요한 것이 배포입니다. GitHub Copilot은 전체 CI/CD 파이프라인 구축을 도와줍니다.

### GitHub Actions 파이프라인

```
"Node.js TypeScript 프로젝트를 위한 GitHub Actions 워크플로우를 만들어줘.
- PR 시 테스트 실행
- main 브랜치 머지 시 자동 배포
- Docker 이미지 빌드 및 푸시
- 환경별 배포 (dev, staging, production)"
```

``yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

env:
  NODE_VERSION: '20.x'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run type check
        run: npm run type-check
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-dev:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: development
    
    steps:
      - name: Deploy to Dev
        run: |
          echo "Deploying to development environment"
          # kubectl apply -f k8s/dev/
          # helm upgrade --install myapp ./charts --namespace dev

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Deploy to Staging
        run: |
          echo "Deploying to staging environment"
          # Staging 배포 명령

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
      - name: Deploy to Production
        run: |
          echo "Deploying to production environment"
          # Production 배포 명령
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### Azure DevOps 파이프라인 (C# 프로젝트)

```
"ASP.NET Core 프로젝트를 위한 Azure DevOps 파이프라인을 만들어줘.
- 빌드
- 단위 테스트
- Azure App Service에 배포"
```

```yaml
# azure-pipelines.yml
trigger:
  branches:
    include:
      - main
      - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  dotnetVersion: '8.x'

stages:
  - stage: Build
    jobs:
      - job: BuildJob
        steps:
          - task: UseDotNet@2
            displayName: 'Install .NET SDK'
            inputs:
              version: $(dotnetVersion)
          
          - task: DotNetCoreCLI@2
            displayName: 'Restore packages'
            inputs:
              command: 'restore'
              projects: '**/*.csproj'
          
          - task: DotNetCoreCLI@2
            displayName: 'Build project'
            inputs:
              command: 'build'
              projects: '**/*.csproj'
              arguments: '--configuration $(buildConfiguration)'
          
          - task: DotNetCoreCLI@2
            displayName: 'Run tests'
            inputs:
              command: 'test'
              projects: '**/*Tests.csproj'
              arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage"'
          
          - task: PublishCodeCoverageResults@1
            displayName: 'Publish coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
          
          - task: DotNetCoreCLI@2
            displayName: 'Publish artifact'
            inputs:
              command: 'publish'
              publishWebProjects: true
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'
          
          - publish: $(Build.ArtifactStagingDirectory)
            artifact: drop

  - stage: DeployDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDevJob
        environment: 'development'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebApp@1
                  inputs:
                    azureSubscription: 'Azure-Subscription'
                    appName: 'myapp-dev'
                    package: '$(Pipeline.Workspace)/drop/**/*.zip'

  - stage: DeployProd
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProdJob
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebApp@1
                  inputs:
                    azureSubscription: 'Azure-Subscription'
                    appName: 'myapp-prod'
                    package: '$(Pipeline.Workspace)/drop/**/*.zip'
```

### Dockerfile 생성

```
"이 Node.js TypeScript 프로젝트를 위한 최적화된 Dockerfile을 만들어줘.
멀티 스테이지 빌드로."
```

```dockerfile
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# 의존성 캐싱을 위해 package 파일만 먼저 복사
COPY package*.json ./
RUN npm ci

# 소스 코드 복사 및 빌드
COPY . .
RUN npm run build

# Production stage
FROM node:20-alpine AS production

WORKDIR /app

# 프로덕션 의존성만 설치
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 빌드된 파일 복사
COPY --from=builder /app/dist ./dist

# 보안을 위해 non-root 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001
USER nodejs

# 헬스체크
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

EXPOSE 3000

CMD ["node", "dist/main.js"]
```

### Kubernetes 배포 설정

```
"Kubernetes에 배포하기 위한 매니페스트 파일들을 생성해줘.
Deployment, Service, ConfigMap, Secret 포함."
```

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: ghcr.io/myorg/myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
data:
  LOG_LEVEL: "info"
  API_TIMEOUT: "30000"

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
type: Opaque
stringData:
  database-url: "postgresql://user:password@host:5432/db"
  api-key: "your-secret-api-key"
```

### 환경별 배포 전략

**블루-그린 배포**

```
"블루-그린 배포 전략을 GitHub Actions로 구현해줘."
```

```yaml
deploy-blue-green:
  runs-on: ubuntu-latest
  steps:
    - name: Deploy to Green Environment
      run: |
        kubectl apply -f k8s/green/
        kubectl wait --for=condition=ready pod -l app=myapp,env=green --timeout=300s
    
    - name: Run Smoke Tests
      run: |
        curl -f https://green.myapp.com/health || exit 1
    
    - name: Switch Traffic to Green
      run: |
        kubectl patch service myapp-service -p '{"spec":{"selector":{"env":"green"}}}'
    
    - name: Wait and Monitor
      run: sleep 300
    
    - name: Cleanup Blue Environment
      if: success()
      run: |
        kubectl delete -f k8s/blue/
```

### 롤백 전략

```
"배포 실패 시 자동 롤백을 구현해줘."
```

```yaml
deploy-with-rollback:
  runs-on: ubuntu-latest
  steps:
    - name: Deploy New Version
      id: deploy
      continue-on-error: true
      run: |
        kubectl set image deployment/myapp myapp=${{ env.NEW_IMAGE }}
        kubectl rollout status deployment/myapp --timeout=5m
    
    - name: Run Health Checks
      if: steps.deploy.outcome == 'success'
      id: health
      continue-on-error: true
      run: |
        for i in {1..10}; do
          if curl -f https://myapp.com/health; then
            echo "Health check passed"
            exit 0
          fi
          sleep 30
        done
        exit 1
    
    - name: Rollback on Failure
      if: steps.deploy.outcome == 'failure' || steps.health.outcome == 'failure'
      run: |
        echo "Deployment failed, rolling back..."
        kubectl rollout undo deployment/myapp
        kubectl rollout status deployment/myapp
    
    - name: Notify Team
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'Deployment failed and rolled back'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

// 이미지로 교체되어야 함 : CI/CD 파이프라인의 전체 흐름도 - 코드 커밋 → 빌드 → 테스트 → 도커 이미지 → 배포 → 모니터링, 각 단계별 자동화 아이콘
프롬프트: A horizontal CI/CD pipeline flow diagram: Git commit (git branch icon) → Build (hammer icon) → Test (checkmark list) → Docker Image (container icon) → Deploy to Kubernetes (ship wheel) → Monitor (dashboard), connected by arrows, each stage has automation symbol (robot arm), includes feedback loop from monitor back to git, professional DevOps style, orange and blue color scheme

### 모니터링 및 알림

```
"배포 후 모니터링과 알림을 설정해줘. Prometheus + Grafana."
```

```yaml
# k8s/prometheus-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    
    scrape_configs:
      - job_name: 'myapp'
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_label_app]
            action: keep
            regex: myapp
    
    alerting:
      alertmanagers:
        - static_configs:
            - targets: ['alertmanager:9093']
    
    rule_files:
      - '/etc/prometheus/rules/*.yml'

---
# k8s/alert-rules.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-rules
data:
  app.rules: |
    groups:
      - name: app_alerts
        rules:
          - alert: HighErrorRate
            expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
            for: 5m
            labels:
              severity: critical
            annotations:
              summary: "High error rate detected"
              description: "Error rate is {{ $value }} errors per second"
          
          - alert: HighMemoryUsage
            expr: container_memory_usage_bytes{pod=~"myapp-.*"} / container_spec_memory_limit_bytes > 0.9
            for: 5m
            labels:
              severity: warning
            annotations:
              summary: "High memory usage"
              description: "Memory usage is above 90%"
```

## 실습 결과 요약

이번 챕터에서는 바이브 코딩을 실무 환경에 적용하는 세 가지 핵심 전략을 마스터했습니다. 이제 이론을 넘어 실제 프로젝트에서 GitHub Copilot을 전략적으로 활용할 수 있게 되었습니다.

### 핵심 성과

**1. 레거시 현대화 역량**

레거시 코드는 더 이상 두려운 대상이 아닙니다. 체계적인 접근으로 점진적 개선이 가능함을 배웠습니다:

- **분석 단계**: GitHub Copilot으로 복잡한 코드의 구조와 의도를 빠르게 파악
- **Strangler Fig 패턴**: 한 번에 바꾸지 않고 점진적으로 새로운 코드로 대체
- **테스트 우선**: 캐릭터라이제이션 테스트로 안전망 확보 후 리팩토링
- **.NET 마이그레이션**: Framework에서 .NET 8로의 현대화 전략

실무 적용 시: 가장 자주 변경되거나 문제가 많은 모듈부터 시작하세요. 전체를 한 번에 바꾸려 하지 말고, 한 모듈씩 점진적으로 개선합니다.

**2. 테스트 자동화 전문성**

GitHub Copilot은 테스트 작성의 부담을 극적으로 줄여줍니다:

- **단위 테스트**: 모든 메서드에 대해 정상/엣지/에러 케이스 자동 생성
- **통합 테스트**: E2E 시나리오를 포괄적으로 커버
- **테스트 유지보수**: 코드 변경 시 테스트도 함께 업데이트
- **커버리지 향상**: 놓친 부분을 AI가 식별하고 테스트 제안

실무 적용 시: 새로운 기능 개발 시 코드와 테스트를 동시에 생성하는 습관을 들이세요. GitHub Copilot은 코드를 보고 즉시 관련 테스트를 제안합니다.

**3. CI/CD 파이프라인 구축**

전체 배포 프로세스를 자동화하는 방법을 배웠습니다:

- **GitHub Actions**: PR부터 프로덕션 배포까지 완전 자동화
- **Azure DevOps**: .NET 프로젝트의 빌드, 테스트, 배포
- **Docker & Kubernetes**: 컨테이너 기반 배포 전략
- **블루-그린 배포**: 무중단 배포와 자동 롤백

실무 적용 시: 작은 것부터 시작하세요. 먼저 PR 시 자동 테스트만 구현하고, 점차 배포까지 확장합니다.

### 통합 워크플로우

세 가지 전략을 결합한 완벽한 개발 워크플로우:

1. **레거시 개선 착수**
   - GitHub Copilot으로 코드 분석
   - 리팩토링 계획 수립
   
2. **테스트 먼저 작성**
   - 캐릭터라이제이션 테스트로 현재 동작 보장
   - 새로운 구조에 대한 단위 테스트 작성
   
3. **점진적 리팩토링**
   - 한 번에 하나씩 모듈 개선
   - 각 단계마다 테스트 실행
   
4. **자동화된 배포**
   - PR 생성 시 자동 테스트
   - 머지 시 자동 배포
   - 모니터링으로 문제 조기 발견

### 실전 팁

**시간 절약 극대화**
- 반복 작업은 모두 자동화
- 프롬프트 템플릿 라이브러리 구축
- CI/CD 파이프라인은 재사용 가능하게 설계

**품질 보장**
- 테스트 커버리지 80% 이상 목표
- 배포 전 자동 품질 체크
- 프로덕션 배포는 승인 단계 추가

**팀 협업**
- 프롬프트 패턴을 팀과 공유
- CI/CD 파이프라인을 표준화
- 배포 프로세스 문서화

### 다음 단계

다음 챕터에서는 컴퓨팅 사고를 고도화하고 바이브 코딩을 심화합니다:
- 대규모 시스템 분해 전략
- 복잡한 디자인 패턴 적용
- 고급 프롬프트 엔지니어링
- 성능 최적화 전략

Chapter 8에서 배운 실전 기술을 바탕으로, Chapter 9에서는 더 복잡하고 고급 주제를 다룹니다.

### 체크리스트

다음 항목을 확인하며 이번 챕터 학습을 점검하세요:

**레거시 현대화**
- [ ] 복잡한 레거시 코드를 분석하고 이해할 수 있다
- [ ] Strangler Fig 패턴으로 점진적 리팩토링을 수행할 수 있다
- [ ] 캐릭터라이제이션 테스트를 작성할 수 있다
- [ ] .NET Framework를 .NET 8로 마이그레이션할 수 있다

**테스트 자동화**
- [ ] GitHub Copilot으로 단위 테스트를 자동 생성할 수 있다
- [ ] E2E 테스트 시나리오를 설계하고 구현할 수 있다
- [ ] 테스트 커버리지를 분석하고 개선할 수 있다
- [ ] C# XUnit/Moq 테스트를 작성할 수 있다

**CI/CD 파이프라인**
- [ ] GitHub Actions 워크플로우를 작성할 수 있다
- [ ] Azure DevOps 파이프라인을 구성할 수 있다
- [ ] Docker 이미지를 빌드하고 배포할 수 있다
- [ ] Kubernetes 매니페스트를 작성할 수 있다
- [ ] 블루-그린 배포를 구현할 수 있다

모든 항목에 체크했다면, 바이브 코딩 실전 전문가로서의 기반을 확립한 것입니다!

---

**실습 과제**

이번 챕터 내용을 자신의 프로젝트에 적용해보세요:

1. **레거시 개선 실습** (4시간)
   - 자신의 레거시 코드 중 가장 복잡한 함수 1개 선택
   - GitHub Copilot으로 분석 및 리팩토링
   - 테스트 추가

2. **테스트 자동화 실습** (3시간)
   - 테스트가 없는 모듈에 단위 테스트 추가
   - 전체 플로우 E2E 테스트 작성
   - 커버리지 80% 목표 달성

3. **CI/CD 구축 실습** (5시간)
   - GitHub Actions 또는 Azure DevOps 파이프라인 구성
   - Dockerfile 작성
   - 자동 배포 설정

총 12시간 투자로 실무에 즉시 활용 가능한 자동화 인프라를 구축할 수 있습니다!
