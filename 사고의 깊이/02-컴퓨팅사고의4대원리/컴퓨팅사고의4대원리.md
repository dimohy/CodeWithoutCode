# 2주차: 컴퓨팅 사고의 4대 원리

## 개요

지난 주에 우리는 바이브 코딩이 단순히 AI에게 코드를 맡기는 것이 아니라, 더 높은 차원의 사고를 요구하는 새로운 패러다임임을 배웠습니다. 이번 주에는 그 사고의 핵심인 **컴퓨팅 사고(Computational Thinking)**를 집중적으로 탐구합니다.

컴퓨팅 사고는 복잡한 문제를 컴퓨터가 해결할 수 있는 형태로 분해하고, 구조화하고, 표현하는 사고 체계입니다. 이는 프로그래머만의 전유물이 아니라, 현대 사회에서 누구에게나 필요한 핵심 역량입니다. 하지만 전문 개발자에게 컴퓨팅 사고는 특별한 의미를 갖습니다. 이것은 AI에게 의도를 정확히 전달하고, 복잡한 시스템을 설계하며, 생성된 코드의 품질을 판단하는 기초가 되기 때문입니다.

컴퓨팅 사고는 네 가지 핵심 원리로 구성됩니다: **분해(Decomposition)**, **패턴 인식(Pattern Recognition)**, **추상화(Abstraction)**, **알고리즘적 사고(Algorithmic Thinking)**. 이 네 가지는 독립적으로 작동하는 것이 아니라, 서로 유기적으로 연결되어 강력한 문제 해결 프레임워크를 형성합니다.

이번 챕터에서는 각 원리를 전문가 관점에서 깊이 있게 다룹니다. 단순한 개념 설명을 넘어, 대규모 시스템 설계에 어떻게 적용되는지, 설계 패턴과 어떻게 연결되는지, GitHub Copilot과의 협업에서 어떤 역할을 하는지를 실습을 통해 체득하게 됩니다.

**학습 목표:**
- 컴퓨팅 사고의 4대 원리를 전문가 수준으로 이해하기
- 복잡한 시스템을 모듈로 분해하고 의존성을 관리하는 전략 습득하기
- 설계 패턴을 식별하고 적용하는 능력 키우기
- 추상화 계층을 설계하고 인터페이스를 정의하는 기법 익히기
- 알고리즘적 사고로 효율적인 문제 해결 프로세스 수립하기
- GitHub Copilot에게 각 원리를 적용한 명확한 프롬프트 작성하기

// 이미지로 교체되어야 함 : 컴퓨팅 사고 4대 원리의 관계를 보여주는 순환 다이어그램
프롬프트: A circular diagram showing the 4 pillars of computational thinking (Decomposition, Pattern Recognition, Abstraction, Algorithmic Thinking) connected with arrows in a cycle, each pillar represented by an icon, modern flat design style, professional color scheme with blues and purples, clean and minimalist, technical illustration

## 1. 컴퓨팅 사고란 무엇인가 - 왜 필요한가

### 전문가를 위한 컴퓨팅 사고의 정의

컴퓨팅 사고(Computational Thinking)는 2006년 카네기 멜론 대학의 지넷 윙(Jeannette Wing) 교수가 제안한 개념으로, "컴퓨터 과학의 기본 개념을 이용하여 문제를 해결하고, 시스템을 설계하며, 인간의 행동을 이해하는 사고 과정"을 의미합니다. 하지만 전문 개발자에게 컴퓨팅 사고는 단순히 문제를 푸는 방법이 아닙니다. 이것은 **시스템을 바라보는 렌즈**이자, **복잡성을 다루는 도구**이며, **AI와 소통하는 언어**입니다.

전문가 관점에서 컴퓨팅 사고는 세 가지 차원으로 이해할 수 있습니다.

**첫째, 문제 공간에서 솔루션 공간으로의 번역 능력입니다.** 비즈니스 요구사항, 사용자 니즈, 시스템 제약 조건 등의 문제 공간을 분석하여, 데이터 구조, 알고리즘, 아키텍처 패턴 등의 솔루션 공간으로 변환하는 능력입니다. 이는 단순한 코딩 능력을 넘어서는 것으로, 추상적인 요구사항을 구체적이고 실행 가능한 설계로 만드는 과정입니다.

**둘째, 복잡성 관리 전략입니다.** 현대 소프트웨어는 수백만 줄의 코드, 수십 개의 마이크로서비스, 복잡한 의존성 그래프로 이루어져 있습니다. 컴퓨팅 사고는 이러한 복잡성을 관리 가능한 단위로 나누고, 계층적으로 조직하며, 명확한 인터페이스로 연결하는 방법을 제공합니다. 이는 시스템이 커질수록 더욱 중요해집니다.

**셋째, 형식화된 의사소통 수단입니다.** 팀원들과 설계를 논의할 때, AI에게 요구사항을 전달할 때, 코드 리뷰를 할 때, 컴퓨팅 사고의 프레임워크를 사용하면 모호함이 줄어들고 명확성이 높아집니다. "이 기능을 좀 더 모듈화해야 해"(분해), "여기서 팩토리 패턴을 쓰면 어떨까?"(패턴 인식), "이 인터페이스를 더 추상화하자"(추상화), "이 로직의 시간 복잡도를 개선해야 해"(알고리즘적 사고)와 같은 대화가 가능해집니다.

### AI 시대에 컴퓨팅 사고가 더 중요한 이유

역설적이게도, AI가 코드를 생성하는 시대에 컴퓨팅 사고는 더욱 중요해졌습니다. 그 이유를 살펴봅시다.

**1. AI는 명확한 지시를 필요로 합니다**

AI는 모호한 요청보다 명확한 지시에서 훨씬 나은 결과를 생성합니다. "사용자 관리 기능을 만들어줘"보다 "사용자 엔티티를 User, Role, Permission으로 분해하고(분해), RBAC 패턴을 적용하며(패턴 인식), 인증과 인가를 별도 레이어로 추상화하고(추상화), JWT 토큰 검증 알고리즘을 구현해줘(알고리즘적 사고)"가 훨씬 좋은 코드를 만듭니다. 컴퓨팅 사고는 이러한 명확한 지시를 만드는 기반입니다.

**2. 생성된 코드의 품질을 판단해야 합니다**

AI가 생성한 코드가 문제를 올바르게 분해했는지, 적절한 패턴을 사용했는지, 추상화 레벨이 적절한지, 알고리즘이 효율적인지를 판단하려면 컴퓨팅 사고가 필수입니다. 컴퓨팅 사고는 코드 품질을 평가하는 기준을 제공합니다.

**3. 시스템 전체를 조망해야 합니다**

AI는 로컬 최적화에는 뛰어나지만, 시스템 전체의 일관성을 보장하기는 어렵습니다. "이 마이크로서비스를 어떻게 분해할까?", "서비스 간 통신 패턴은 무엇을 사용할까?", "공통 기능은 어떻게 추상화할까?"와 같은 고수준 결정은 여전히 인간의 몫입니다. 컴퓨팅 사고는 이러한 아키텍처 레벨의 의사결정을 돕습니다.

**4. 문제의 본질을 파악해야 합니다**

AI에게 요청하기 전에, 문제가 무엇인지를 명확히 이해해야 합니다. "이 기능이 느려"라는 문제를 해결하려면, 먼저 병목이 데이터베이스 쿼리인지, 알고리즘 복잡도인지, 네트워크 레이턴시인지 등을 분해하여 파악해야 합니다(분해). 그런 다음 유사한 성능 문제의 해결 패턴을 식별하고(패턴 인식), 캐싱이나 인덱싱 같은 추상화 레이어를 추가하며(추상화), 최적화된 알고리즘을 적용합니다(알고리즘적 사고). 컴퓨팅 사고는 문제의 본질을 드러냅니다.

**5. 지속적인 개선이 필요합니다**

소프트웨어는 한 번 만들고 끝나는 것이 아닙니다. 지속적으로 진화합니다. 새로운 요구사항이 추가될 때, 기존 시스템을 어떻게 확장할지(분해), 어떤 검증된 패턴을 적용할지(패턴 인식), 어떤 인터페이스를 유지하고 변경할지(추상화), 어떻게 성능을 개선할지(알고리즘적 사고)를 결정하는 것은 컴퓨팅 사고의 영역입니다.

결국 AI 시대의 개발자는 "타이핑하는 사람"에서 "생각하는 사람"으로 역할이 변합니다. 그리고 그 생각의 체계가 바로 컴퓨팅 사고입니다. AI는 여러분의 컴퓨팅 사고를 코드로 변환하는 도구이지, 컴퓨팅 사고를 대체하는 것이 아닙니다.

## 2. 분해(Decomposition): 복잡한 시스템을 모듈로

### 분해의 원리와 전략

분해(Decomposition)는 복잡한 문제나 시스템을 더 작고 관리 가능한 부분으로 나누는 과정입니다. 이는 컴퓨팅 사고의 가장 기본적이면서도 가장 중요한 원리입니다. 인간의 인지 능력은 한계가 있습니다. 한 번에 7±2개의 정보만 작업 기억에 유지할 수 있다는 밀러의 법칙(Miller's Law)이 잘 보여주듯이, 우리는 복잡한 것을 단순하게 만들어야 이해하고 다룰 수 있습니다.

소프트웨어 개발에서 분해는 여러 차원에서 일어납니다.

**시스템 레벨 분해**에서는 전체 시스템을 독립적인 서비스나 모듈로 나눕니다. 예를 들어, 이커머스 시스템을 사용자 관리, 상품 관리, 주문 처리, 결제, 배송 추적 등의 서비스로 분해할 수 있습니다. 이는 마이크로서비스 아키텍처의 기초가 됩니다.

**모듈 레벨 분해**에서는 각 서비스를 더 작은 모듈로 나눕니다. 사용자 관리 서비스를 인증(Authentication), 인가(Authorization), 프로필 관리, 세션 관리 등의 모듈로 분해할 수 있습니다.

**함수 레벨 분해**에서는 각 모듈의 기능을 개별 함수나 메서드로 나눕니다. 인증 모듈을 로그인, 로그아웃, 토큰 발급, 토큰 검증, 비밀번호 재설정 등의 함수로 분해합니다.

분해를 효과적으로 수행하는 전략은 다음과 같습니다.

**단일 책임 원칙(Single Responsibility Principle)**을 따르세요. 각 부분은 하나의 명확한 책임만 가져야 합니다. "사용자 인증과 로깅과 이메일 발송을 하는 함수"가 아니라, "사용자 인증을 하는 함수", "로그를 기록하는 함수", "이메일을 발송하는 함수"로 분해해야 합니다.

**응집도는 높이고 결합도는 낮추세요**. 관련된 기능은 같은 모듈에 모으고(높은 응집도), 모듈 간 의존성은 최소화합니다(낮은 결합도). 이렇게 하면 각 모듈을 독립적으로 이해하고 수정할 수 있습니다.

**의미있는 경계를 찾으세요**. 분해는 임의로 하는 것이 아닙니다. 도메인의 자연스러운 경계, 변경 빈도의 차이, 성능 요구사항의 차이, 보안 수준의 차이 등을 고려하여 의미있는 경계를 찾아야 합니다.

### 대규모 문제를 관리 가능한 단위로 나누기

대규모 시스템을 분해하는 것은 예술이자 과학입니다. 너무 많이 나누면 관리 오버헤드가 증가하고, 너무 적게 나누면 복잡도가 감당하기 어려워집니다. 적절한 균형을 찾는 것이 중요합니다.

**도메인 주도 설계(Domain-Driven Design, DDD)**는 대규모 시스템 분해의 강력한 프레임워크입니다. DDD는 비즈니스 도메인을 중심으로 시스템을 분해하고, 각 도메인을 **경계 컨텍스트(Bounded Context)**로 격리합니다. 예를 들어, 온라인 쇼핑몰에서 "상품"이라는 개념은 카탈로그 컨텍스트, 재고 컨텍스트, 주문 컨텍스트에서 각각 다른 의미와 속성을 가질 수 있습니다. 이를 인식하고 각 컨텍스트를 독립적으로 모델링하는 것이 DDD의 핵심입니다.

**이벤트 스토밍(Event Storming)**은 도메인을 이벤트 중심으로 분해하는 기법입니다. 시스템에서 일어나는 주요 이벤트들(주문 생성됨, 결제 완료됨, 배송 시작됨 등)을 식별하고, 이벤트를 중심으로 기능을 그룹화합니다. 이는 특히 이벤트 드리븐 아키텍처에 유용합니다.

**레이어드 아키텍처(Layered Architecture)**는 시스템을 수평적 레이어로 분해합니다. 전형적으로 프레젠테이션 레이어, 비즈니스 로직 레이어, 데이터 액세스 레이어로 나뉩니다. 각 레이어는 명확한 책임을 가지며, 상위 레이어는 하위 레이어에만 의존합니다.

분해할 때 **MECE 원칙(Mutually Exclusive, Collectively Exhaustive)**을 따르는 것이 좋습니다. 즉, 각 부분은 서로 중복되지 않고(Mutually Exclusive), 전체를 빠짐없이 커버해야 합니다(Collectively Exhaustive). 이렇게 하면 책임이 명확해지고 누락이나 중복이 없습니다.

### 모듈 간 의존성 관리

분해의 진정한 도전은 모듈을 나눈 후에 시작됩니다. 모듈 간의 의존성을 어떻게 관리하느냐가 시스템의 유지보수성, 확장성, 테스트 가능성을 결정합니다.

**의존성 역전 원칙(Dependency Inversion Principle, DIP)**은 고수준 모듈이 저수준 모듈에 직접 의존하지 않고, 둘 다 추상화에 의존해야 한다는 원칙입니다. 예를 들어, 비즈니스 로직이 특정 데이터베이스 구현에 의존하지 않고, 리포지토리 인터페이스에 의존하게 만들면, 데이터베이스를 교체해도 비즈니스 로직은 변경할 필요가 없습니다.

**순환 의존성(Circular Dependency)**은 반드시 피해야 합니다. 모듈 A가 B에 의존하고, B가 다시 A에 의존하면, 두 모듈은 사실상 하나가 됩니다. 이는 분해의 이점을 모두 잃게 만듭니다. 순환 의존성이 발견되면, 공통 부분을 새로운 모듈로 추출하거나, 인터페이스를 도입하여 의존성 방향을 정리해야 합니다.

**의존성 그래프를 시각화**하면 시스템의 구조를 이해하고 문제를 발견하는 데 도움이 됩니다. 의존성이 복잡하게 얽혀 있다면, 분해가 잘못되었을 가능성이 높습니다. 이상적인 의존성 그래프는 트리 구조에 가까워야 합니다.

// 이미지로 교체되어야 함 : 마이크로서비스 아키텍처 분해 예시 - 이커머스 시스템을 여러 서비스로 분해한 구조도
프롬프트: A microservices architecture diagram showing an e-commerce system decomposed into multiple services (User Service, Product Service, Order Service, Payment Service, Notification Service), each service as a rounded rectangle with icons, connected by arrows showing communication patterns, clean technical diagram style, modern color palette, professional look

**이벤트 기반 통신**은 모듈 간 결합도를 낮추는 효과적인 방법입니다. 모듈 A가 모듈 B를 직접 호출하는 대신, A가 이벤트를 발행하고 B가 그 이벤트를 구독하게 만들면, 두 모듈은 서로를 몰라도 됩니다. 이는 특히 마이크로서비스 아키텍처에서 유용합니다.

### 실습: 복잡한 시스템 분해하기

이제 GitHub Copilot과 함께 복잡한 시스템을 분해하는 실습을 해봅시다.

**실습 시나리오**: 소셜 미디어 플랫폼 설계하기

다음 요구사항을 가진 소셜 미디어 플랫폼을 설계한다고 가정합니다:
- 사용자는 게시물을 작성, 수정, 삭제할 수 있습니다
- 사용자는 다른 사용자를 팔로우할 수 있습니다
- 사용자는 게시물에 좋아요와 댓글을 남길 수 있습니다
- 피드는 팔로우하는 사용자의 게시물을 시간순으로 표시합니다
- 사용자는 다이렉트 메시지를 주고받을 수 있습니다
- 시스템은 알림을 발송합니다 (새 팔로워, 새 댓글 등)

GitHub Copilot Chat에게 다음과 같이 요청합니다:

```
소셜 미디어 플랫폼을 마이크로서비스 아키텍처로 설계하려고 해.
위 요구사항을 분석하고, 다음을 제안해줘:

1. 서비스 분해: 어떤 마이크로서비스들로 나눌 것인가?
2. 각 서비스의 책임: 각 서비스는 무엇을 담당하는가?
3. 서비스 간 통신: 어떤 방식으로 통신하는가? (동기/비동기)
4. 데이터 관리: 각 서비스의 데이터 저장소는 어떻게 구성하는가?

DDD의 경계 컨텍스트 개념을 적용하고,
단일 책임 원칙을 지키며,
서비스 간 결합도를 최소화하는 방향으로 설계해줘.
```

Copilot이 제안한 분해를 검토합니다. 다음 질문을 스스로에게 던져보세요:

- 각 서비스의 경계가 명확한가?
- 서비스 간 의존성이 최소화되었는가?
- 순환 의존성은 없는가?
- 각 서비스를 독립적으로 배포하고 확장할 수 있는가?
- 장애 격리(Failure Isolation)가 가능한가?

문제가 발견되면 Copilot에게 개선을 요청합니다:

```
User Service와 Feed Service 사이에 의존성이 강한 것 같아.
Feed Service가 User Service의 변경에 민감하지 않도록
느슨한 결합으로 개선해줘.
```

이러한 반복적인 분해와 개선 과정을 통해, 최종적으로는 각 서비스가 명확한 책임을 가지고, 느슨하게 결합되며, 독립적으로 진화할 수 있는 아키텍처에 도달하게 됩니다.

## 3. 패턴 인식(Pattern Recognition): 설계 패턴과 재사용

### 패턴 인식의 원리

패턴 인식(Pattern Recognition)은 문제나 데이터에서 반복되는 구조, 규칙성, 유사성을 찾아내는 과정입니다. 소프트웨어 개발에서 이는 "이전에 비슷한 문제를 본 적이 있는가?"라는 질문으로 시작됩니다. 패턴을 인식할 수 있다면, 그 문제에 대한 검증된 해결책을 재사용할 수 있습니다. 이는 바퀴를 다시 발명하지 않고, 집단 지성의 혜택을 누리는 것입니다.

패턴 인식의 힘은 **전이(Transfer)**에 있습니다. 한 영역에서 배운 패턴을 다른 영역에 적용할 수 있습니다. 옵저버 패턴(Observer Pattern)은 GUI 이벤트 처리에서 시작되었지만, 이제는 마이크로서비스의 이벤트 드리븐 아키텍처, 반응형 프로그래밍, 상태 관리 라이브러리 등 다양한 곳에서 사용됩니다. 패턴을 안다는 것은 하나의 솔루션이 아니라 솔루션의 템플릿을 아는 것입니다.

소프트웨어 개발에서 패턴은 여러 레벨에 존재합니다.

**아키텍처 패턴**은 시스템 전체의 구조를 정의합니다. MVC(Model-View-Controller), 레이어드 아키텍처, 마이크로서비스, 이벤트 드리븐 아키텍처, CQRS(Command Query Responsibility Segregation) 등이 여기에 속합니다.

**설계 패턴**은 코드 레벨의 문제를 해결합니다. Gang of Four의 23가지 디자인 패턴(싱글톤, 팩토리, 옵저버, 전략, 데코레이터 등)이 대표적입니다. 이들은 객체지향 설계의 반복되는 문제에 대한 검증된 솔루션을 제공합니다.

**이디엄(Idioms)**은 특정 언어나 프레임워크에서 권장되는 코딩 방식입니다. Python의 리스트 컴프리헨션, JavaScript의 Promise 체이닝, React의 Hooks 패턴 등이 이에 해당합니다.

### 반복되는 문제 구조 식별

패턴을 적용하기 전에, 먼저 문제의 구조를 파악해야 합니다. 다음은 흔히 마주치는 문제 구조와 그에 대응하는 패턴입니다.

**"객체 생성이 복잡하다"** - 팩토리 패턴(Factory Pattern)이나 빌더 패턴(Builder Pattern)을 고려하세요. 객체 생성 로직이 여러 곳에 흩어져 있거나, 생성 과정이 복잡하거나, 생성할 객체의 타입이 런타임에 결정된다면 이 패턴들이 유용합니다.

**"한 객체의 상태 변화를 여러 객체가 알아야 한다"** - 옵저버 패턴(Observer Pattern)이나 Pub/Sub 패턴을 사용하세요. GUI 이벤트, 상태 관리, 이벤트 드리븐 시스템에서 자주 나타나는 문제입니다.

**"런타임에 객체의 행동을 변경해야 한다"** - 전략 패턴(Strategy Pattern)이나 상태 패턴(State Pattern)을 검토하세요. 알고리즘을 교체하거나, 상태에 따라 행동이 달라져야 하는 경우에 적합합니다.

**"기존 객체에 새로운 기능을 추가하고 싶다"** - 데코레이터 패턴(Decorator Pattern)이나 프록시 패턴(Proxy Pattern)을 고려하세요. 기존 코드를 수정하지 않고 기능을 확장할 수 있습니다.

**"복잡한 하위 시스템을 단순한 인터페이스로 노출하고 싶다"** - 파사드 패턴(Facade Pattern)을 사용하세요. 여러 클래스나 API를 하나의 간단한 인터페이스로 래핑할 수 있습니다.

패턴을 식별하는 핵심은 **문제의 본질을 파악하는 것**입니다. 표면적인 요구사항이 아니라, 그 이면의 구조적 문제를 봐야 합니다. "사용자가 로그인 방법을 선택할 수 있게 해달라"는 요구사항의 본질은 "런타임에 인증 알고리즘을 교체한다"이고, 이는 전략 패턴의 문제 구조입니다.

### 검증된 솔루션 패턴 활용

패턴을 안다는 것과 패턴을 제대로 사용한다는 것은 다릅니다. 패턴은 은탄환이 아닙니다. 잘못 사용하면 오히려 복잡도를 증가시킵니다.

**패턴을 적용하기 전에 다음을 확인하세요:**

**1. 문제가 정말 그 패턴의 문제 구조와 일치하는가?**  
패턴을 위한 패턴은 과잉 설계입니다. 싱글톤 패턴은 유용하지만, 모든 클래스를 싱글톤으로 만들 필요는 없습니다.

**2. 현재 시스템의 규모와 복잡도에 적합한가?**  
작은 프로젝트에 복잡한 아키텍처 패턴을 적용하면 오버헤드만 증가합니다. 반대로 대규모 시스템에 단순한 패턴만 사용하면 확장성에 문제가 생깁니다.

**3. 팀이 그 패턴을 이해하는가?**  
아무리 좋은 패턴이라도 팀원들이 이해하지 못하면 유지보수가 어려워집니다. 패턴 선택 시 팀의 역량을 고려해야 합니다.

**4. 패턴의 트레이드오프를 이해하는가?**  
모든 패턴에는 장단점이 있습니다. 싱글톤은 전역 접근을 제공하지만 테스트를 어렵게 만듭니다. 옵저버 패턴은 느슨한 결합을 제공하지만 디버깅을 복잡하게 만듭니다.

**패턴을 조합하고 변형하세요:**

패턴은 요리 레시피와 같습니다. 레시피를 그대로 따를 수도 있지만, 상황에 맞게 변형하거나 여러 레시피를 조합할 수도 있습니다. 예를 들어:

- 팩토리 패턴 + 전략 패턴: 팩토리가 생성하는 객체가 전략을 구현
- 데코레이터 패턴 + 팩토리 패턴: 팩토리가 데코레이터로 감싸진 객체를 생성
- 옵저버 패턴 + 커맨드 패턴: 이벤트를 커맨드 객체로 캡슐화

현대 프레임워크는 여러 패턴을 조합하여 설계됩니다. React는 컴포넌트 패턴, HOC(Higher-Order Component), Hooks 등을 조합합니다. Spring Framework는 의존성 주입, 프록시, 템플릿 메서드 등을 사용합니다.

### 실습: 설계 패턴 적용하기

GitHub Copilot과 함께 실제 문제에 패턴을 적용해봅시다.

**실습 시나리오**: 결제 시스템 설계하기

여러 결제 수단(신용카드, 계좌이체, 간편결제)을 지원하는 결제 시스템을 만들어야 합니다. 각 결제 수단은 다른 API를 사용하고, 다른 검증 로직을 필요로 합니다.

Copilot에게 다음과 같이 요청합니다:

```
결제 시스템을 설계하려고 해.
다음 요구사항이 있어:

1. 여러 결제 수단 지원 (신용카드, 계좌이체, 간편결제)
2. 각 결제 수단은 다른 검증 로직과 처리 로직을 가짐
3. 런타임에 사용자가 선택한 결제 수단으로 결제
4. 새로운 결제 수단을 쉽게 추가할 수 있어야 함
5. 결제 전후에 로깅, 알림 등의 추가 작업 수행

적절한 디자인 패턴을 적용하여 TypeScript로 구현해줘.
각 패턴을 왜 선택했는지도 설명해줘.
```

Copilot이 생성한 코드를 검토하면서 다음을 확인합니다:

- 전략 패턴이 제대로 적용되었는가? (각 결제 수단을 전략으로)
- 팩토리 패턴이 사용되었는가? (결제 수단 객체 생성)
- 데코레이터나 체인 오브 리스폰서빌리티 패턴이 적용되었는가? (로깅, 알림)
- 개방-폐쇄 원칙(OCP)을 만족하는가? (새 결제 수단 추가 시 기존 코드 수정 불필요)

문제가 있다면 개선을 요청합니다:

```
각 결제 수단 생성 로직이 클라이언트 코드에 노출되어 있어.
팩토리 패턴을 적용해서 결제 수단 생성을 캡슐화해줘.
```

이 실습을 통해 실제 문제에서 패턴을 식별하고, 적절히 적용하며, 코드 품질을 개선하는 과정을 경험하게 됩니다.

## 4. 추상화(Abstraction): 인터페이스와 계층 분리

### 추상화의 원리

추상화(Abstraction)는 복잡한 시스템에서 핵심 개념만 추출하고 불필요한 세부사항은 숨기는 과정입니다. 자동차를 운전할 때 엔진의 작동 원리를 몰라도 되는 것처럼, 잘 설계된 추상화는 사용자가 내부 구현을 몰라도 시스템을 사용할 수 있게 만듭니다.

추상화의 핵심은 **"무엇(What)"과 "어떻게(How)"의 분리**입니다. 인터페이스는 "무엇"을 정의하고, 구현은 "어떻게"를 정의합니다. 데이터베이스 리포지토리 인터페이스는 "데이터를 저장하고 조회한다"는 계약을 정의하지만, 그것이 SQL인지 NoSQL인지, 로컬인지 원격인지는 구현의 몫입니다.

좋은 추상화는 다음 특징을 가집니다:
- **완전성**: 필요한 모든 기능을 제공합니다
- **간결성**: 불필요한 것은 노출하지 않습니다
- **안정성**: 구현이 변경되어도 인터페이스는 안정적입니다
- **일관성**: 유사한 개념은 유사한 방식으로 표현됩니다

### 핵심 개념 추출과 세부 구현 분리

추상화를 만드는 첫 단계는 핵심 개념을 식별하는 것입니다. 이메일 발송 시스템을 예로 들면:

**세부 구현 레벨**에서는: SMTP 프로토콜, 이메일 헤더 구성, MIME 인코딩, 첨부파일 처리, TLS 연결 등의 복잡한 세부사항이 있습니다.

**추상화 레벨**에서는: "수신자, 제목, 본문을 받아 이메일을 발송한다"는 간단한 계약만 노출됩니다.

```typescript
interface EmailService {
  send(to: string, subject: string, body: string): Promise<void>;
}
```

이 추상화는 다양한 방식으로 구현될 수 있습니다: SMTP, SendGrid API, AWS SES, 또는 테스트용 Mock 등. 클라이언트 코드는 이 차이를 몰라도 됩니다.

**의존성 역전**을 통해 추상화의 힘은 극대화됩니다. 비즈니스 로직이 구체적인 이메일 서비스에 의존하지 않고 인터페이스에 의존하면, 테스트도 쉽고 유연성도 높아집니다.

### 계층적 사고와 책임 분리

복잡한 시스템은 여러 추상화 계층으로 구성됩니다. 각 계층은 명확한 책임을 가지며, 하위 계층의 복잡성을 숨깁니다.

**전형적인 웹 애플리케이션의 계층 구조:**

**프레젠테이션 계층**: HTTP 요청/응답, 라우팅, 뷰 렌더링  
**애플리케이션 계층**: 유스케이스 조정, 트랜잭션 관리  
**도메인 계층**: 비즈니스 로직, 도메인 모델  
**인프라 계층**: 데이터베이스, 외부 API, 파일 시스템

// 이미지로 교체되어야 함 : 레이어드 아키텍처의 추상화 계층을 보여주는 다이어그램
프롬프트: A layered architecture diagram showing 4 horizontal layers (Presentation, Application, Domain, Infrastructure) stacked vertically with clear separation lines, arrows showing dependencies flowing downward, each layer labeled with responsibilities, clean technical illustration style, modern design with gradient colors, professional and clear

각 계층은 자신의 관심사에만 집중하고, 다른 계층의 세부사항은 추상화를 통해 접근합니다. 도메인 계층은 데이터가 PostgreSQL에 저장되는지, MongoDB에 저장되는지 알 필요가 없습니다. Repository 추상화만 사용하면 됩니다.

### 실습: 추상화 계층 설계하기

**실습 시나리오**: 파일 저장 시스템 설계하기

로컬 파일 시스템, AWS S3, Azure Blob Storage를 지원하는 파일 저장 시스템을 설계합니다.

Copilot에게 요청:

```
파일 저장 시스템을 설계하려고 해.
다음 저장소를 지원해야 해:
- 로컬 파일 시스템
- AWS S3
- Azure Blob Storage

추상화 계층을 설계하고 TypeScript로 구현해줘.
다음을 고려해서:
1. 인터페이스 분리 원칙 (ISP)
2. 의존성 역전 원칙 (DIP)
3. 각 저장소의 구체적인 구현 숨기기
4. 테스트 가능한 구조
```

생성된 코드를 검토하며 추상화가 적절한지 확인합니다.

## 5. 알고리즘적 사고(Algorithmic Thinking): 효율적 문제 해결 절차

### 알고리즘적 사고의 원리

알고리즘적 사고(Algorithmic Thinking)는 문제를 해결하는 명확한 단계들을 정의하고, 그 과정을 최적화하는 사고방식입니다. 이는 단순히 코딩 알고리즘(정렬, 검색 등)을 아는 것을 넘어, 어떤 문제든 체계적으로 접근하는 방법론입니다.

알고리즘적 사고의 핵심 요소:

**1. 명확성**: 각 단계가 모호하지 않고 정확히 정의되어야 합니다  
**2. 유한성**: 알고리즘은 반드시 종료되어야 합니다  
**3. 효율성**: 시간과 공간 자원을 고려해야 합니다  
**4. 정확성**: 모든 입력에 대해 올바른 출력을 생성해야 합니다

전문가로서 우리는 "작동하는 코드"를 넘어 "효율적인 코드"를 추구합니다. Big-O 표기법으로 시간 복잡도를 분석하고, 병목을 식별하며, 트레이드오프를 고려한 최적화를 수행합니다.

### 단계별 문제 해결 프로세스

알고리즘적 사고의 표준 프로세스:

**1단계: 문제 이해**  
입력은 무엇인가? 출력은 무엇인가? 제약 조건은? 엣지 케이스는?

**2단계: 단순화**  
가장 단순한 경우부터 시작합니다. 작은 입력으로 문제를 푸는 방법을 찾습니다.

**3단계: 패턴 탐색**  
반복, 재귀, 분할 정복 등 적용 가능한 알고리즘 패러다임을 식별합니다.

**4단계: 구현**  
단계를 코드로 변환합니다. 이때 GitHub Copilot이 강력한 도구가 됩니다.

**5단계: 검증**  
다양한 입력으로 테스트하고, 엣지 케이스를 확인합니다.

**6단계: 최적화**  
시간/공간 복잡도를 분석하고, 필요하다면 개선합니다.

### 최적화와 트레이드오프 고려

최적화는 항상 트레이드오프를 수반합니다:

**시간 vs 공간**: 메모이제이션은 시간을 절약하지만 공간을 사용합니다  
**가독성 vs 성능**: 때로는 최적화된 코드가 이해하기 어렵습니다  
**일반성 vs 특수화**: 범용 솔루션은 특정 케이스에서 비효율적일 수 있습니다

성급한 최적화는 악의 근원입니다. 먼저 작동하는 코드를 만들고, 프로파일링으로 병목을 찾은 후, 그곳만 최적화하세요.

### 실습: 알고리즘 설계와 최적화

**실습 시나리오**: 대규모 로그 검색 시스템

수백만 개의 로그 레코드에서 특정 패턴을 찾아야 합니다.

Copilot에게 요청:

```
로그 검색 시스템을 최적화하려고 해.
현재는 모든 로그를 순차적으로 스캔해서 느려.

다음을 구현해줘:
1. 효율적인 인덱싱 전략
2. 검색 알고리즘 최적화
3. 시간 복잡도 분석
4. 대안 접근법 비교

TypeScript로 구현하고, 각 접근법의 장단점을 설명해줘.
```

## 6. 통합 실습: GitHub Copilot으로 4대 원리 적용해보기

### 간단한 시스템 설계 문제

이제 4대 원리를 모두 통합하여 실제 문제를 해결해봅시다.

**종합 실습: 실시간 채팅 시스템 설계**

요구사항:
- 사용자 간 1:1 및 그룹 채팅
- 실시간 메시지 전송 및 수신
- 메시지 히스토리 저장 및 검색
- 읽음/안읽음 상태 관리
- 파일 첨부 기능
- 대규모 동시 접속 지원

### 각 원리를 적용한 프롬프트 작성

**분해를 적용한 프롬프트:**
```
실시간 채팅 시스템을 다음 마이크로서비스로 분해해줘:
1. 사용자 관리 서비스
2. 채팅 세션 관리 서비스
3. 메시지 전송 서비스
4. 알림 서비스
5. 파일 저장 서비스

각 서비스의 책임과 API 엔드포인트를 정의해줘.
```

**패턴 인식을 적용한 프롬프트:**
```
채팅 시스템에 적절한 설계 패턴을 제안해줘:
- 실시간 통신: 어떤 패턴? (WebSocket, Server-Sent Events?)
- 메시지 전달: 어떤 패턴? (Pub/Sub, Message Queue?)
- 상태 관리: 어떤 패턴? (Observer, State Machine?)

각 패턴의 적용 방법과 장단점을 설명해줘.
```

**추상화를 적용한 프롬프트:**
```
채팅 시스템의 추상화 계층을 설계해줘:
1. 메시지 저장소 추상화 (다양한 DB 지원)
2. 메시지 전송 프로토콜 추상화 (WebSocket, HTTP Long Polling)
3. 알림 채널 추상화 (푸시, 이메일, SMS)

각 추상화의 인터페이스를 TypeScript로 정의해줘.
```

**알고리즘적 사고를 적용한 프롬프트:**
```
채팅 시스템의 다음 기능을 최적화해줘:
1. 메시지 히스토리 검색 (수백만 메시지에서 빠른 검색)
2. 읽음 상태 업데이트 (다수 사용자의 상태를 효율적으로 추적)
3. 그룹 채팅 메시지 전파 (대규모 그룹에 메시지를 빠르게 전달)

각 기능의 시간 복잡도를 분석하고, 최적화 전략을 제시해줘.
```

### 결과 비교 및 분석

4대 원리를 적용한 결과와 적용하지 않은 결과를 비교합니다:

**4대 원리 미적용 시:**
- 모놀리식 구조로 확장성 부족
- 코드 중복과 일관성 없는 구현
- 구체 클래스 간 강한 결합
- 비효율적인 알고리즘으로 성능 저하

**4대 원리 적용 시:**
- 명확히 분해된 서비스로 확장 용이
- 검증된 패턴 사용으로 신뢰성 향상
- 추상화를 통한 유연한 구조
- 최적화된 알고리즘으로 빠른 응답

핵심은 4대 원리가 **독립적이 아니라 상호보완적**이라는 점입니다. 분해는 패턴을 적용할 구조를 만들고, 패턴은 추상화를 제공하며, 추상화는 알고리즘 최적화를 용이하게 합니다.

## 7. 실습 결과 요약

### 핵심 포인트 정리

이번 챕터를 통해 컴퓨팅 사고의 4대 원리를 깊이 있게 학습했습니다. 이 원리들은 단순한 이론이 아니라, 매일매일의 개발 업무에서 실제로 사용하는 실천적 도구입니다.

**분해(Decomposition)**는 복잡성을 관리하는 기본 전략입니다. 대규모 시스템을 작은 모듈로 나누고, 각 모듈에 명확한 책임을 부여하며, 의존성을 최소화하는 것이 핵심입니다. 마이크로서비스, DDD, 레이어드 아키텍처 모두 분해의 구체적 적용입니다.

**패턴 인식(Pattern Recognition)**은 바퀴를 다시 발명하지 않게 합니다. 반복되는 문제 구조를 식별하고, 검증된 설계 패턴을 적용하며, 팀의 집단 지성을 활용하는 것입니다. 패턴은 의사소통의 공통 언어이기도 합니다.

**추상화(Abstraction)**는 복잡한 세부사항을 숨기고 핵심만 노출합니다. 인터페이스와 구현을 분리하고, 계층적 구조를 만들며, 의존성을 역전시키는 것이 추상화의 실천입니다. 좋은 추상화는 시스템을 유연하고 테스트 가능하게 만듭니다.

**알고리즘적 사고(Algorithmic Thinking)**는 효율성을 추구합니다. 문제를 단계별로 분해하고, 시간/공간 복잡도를 분석하며, 트레이드오프를 고려한 최적화를 수행합니다. 단, 성급한 최적화는 피하고 측정 기반으로 접근해야 합니다.

### AI 시대의 컴퓨팅 사고

GitHub Copilot과 같은 AI 도구는 컴퓨팅 사고를 더욱 중요하게 만듭니다:

- **명확한 컴퓨팅 사고 → 명확한 프롬프트 → 좋은 코드**
- **모호한 요청 → 모호한 결과 → 많은 수정**

AI는 여러분의 사고를 코드로 변환하는 증폭기입니다. 사고가 명확할수록 결과도 명확합니다. 4대 원리는 AI와 효과적으로 소통하는 프레임워크를 제공합니다.

### 다음 단계

컴퓨팅 사고는 반복적 연습을 통해 내재화됩니다:

1. **매일 연습**: 작은 문제라도 4대 원리를 적용해보세요
2. **코드 리뷰 시 활용**: "이 코드는 어떻게 분해되었나?", "어떤 패턴이 적용되었나?"
3. **설계 토론 시 사용**: 팀원들과 4대 원리를 공통 언어로 사용하세요
4. **AI에게 명확히 지시**: 각 원리를 명시적으로 프롬프트에 포함하세요

### 다음 주차 예고

3주차에서는 **고급 컴퓨팅 사고와 AI 시대의 소프트웨어 아키텍처**를 다룹니다. 4대 원리를 넘어, 문제 공간과 솔루션 공간을 구분하고, 다중 추상화 레벨에서 시스템을 사고하며, AI 협업 기반 설계 패턴을 학습합니다.

**준비 사항:**
- 이번 주 실습한 코드를 되돌아보고 개선점을 찾아보세요
- 여러분의 프로젝트에서 4대 원리가 어떻게 적용되었는지 분석해보세요
- 설계 패턴 책을 하나 골라 읽기 시작하세요 (추천: "Head First Design Patterns" 또는 "Patterns of Enterprise Application Architecture")

**성찰 질문:**
- 가장 이해하기 쉬웠던 원리는 무엇인가요?
- 가장 적용하기 어려웠던 원리는 무엇인가요?
- 여러분의 최근 프로젝트에서 4대 원리를 얼마나 잘 적용했나요?
- GitHub Copilot과 협업할 때 4대 원리가 어떻게 도움이 되었나요?

---

### 실전 적용 가이드

컴퓨팅 사고를 일상 업무에 통합하는 구체적인 방법을 제시합니다.

**새로운 프로젝트 시작 시:**

1. **분해 먼저**: 요구사항을 받으면 즉시 GitHub Copilot과 함께 분해를 시작하세요
   - "이 시스템을 어떤 서비스/모듈로 나눌 수 있을까?"
   - "각 모듈의 경계는 어디일까?"
   - "의존성 그래프를 그려보면 어떤 모습일까?"

2. **패턴 탐색**: 유사한 문제를 해결한 경험을 되돌아보세요
   - "이전에 비슷한 구조를 본 적이 있는가?"
   - "업계 표준 패턴은 무엇인가?"
   - "이 문제에 적합한 아키텍처 패턴은?"

3. **추상화 설계**: 변경 가능한 부분을 식별하세요
   - "어떤 부분이 자주 변경될까?"
   - "어떤 부분을 교체 가능하게 만들어야 할까?"
   - "인터페이스를 어떻게 정의할까?"

4. **성능 고려**: 병목을 예상하세요
   - "어떤 작업이 많은 데이터를 처리할까?"
   - "실시간 응답이 필요한 부분은?"
   - "어디를 최적화해야 할까?"

**코드 리뷰 시:**

4대 원리를 체크리스트로 사용하세요:

- [ ] 분해: 각 함수/클래스가 하나의 명확한 책임을 가지는가?
- [ ] 패턴: 적절한 설계 패턴이 적용되었는가? 재사용성이 고려되었는가?
- [ ] 추상화: 인터페이스와 구현이 분리되었는가? 의존성이 올바른 방향인가?
- [ ] 알고리즘: 시간/공간 복잡도가 적절한가? 최적화가 필요한가?

**디버깅 시:**

컴퓨팅 사고로 문제를 구조화하세요:

1. **분해**: 문제를 작은 부분으로 나누어 격리
2. **패턴**: 유사한 버그를 이전에 본 적이 있는지 확인
3. **추상화**: 어느 레벨에서 문제가 발생했는지 식별
4. **알고리즘**: 로직의 각 단계를 추적

**팀 협업 시:**

4대 원리를 공통 언어로 사용하세요:

- "이 모듈을 더 분해해야 할 것 같아요" (분해)
- "여기서 Strategy 패턴을 쓰면 어떨까요?" (패턴)
- "이 인터페이스를 더 추상화할 수 있을 것 같아요" (추상화)
- "이 알고리즘의 시간 복잡도를 개선해야 해요" (알고리즘)

이렇게 명확한 용어를 사용하면 의사소통이 정확해지고, 회의가 생산적이 됩니다.

### 흔한 실수와 해결책

컴퓨팅 사고를 적용할 때 흔히 범하는 실수들:

**과도한 분해**: 모든 것을 마이크로서비스로 만들 필요는 없습니다. 시스템의 규모와 복잡도에 맞게 조절하세요. 작은 프로젝트는 모놀리식도 충분합니다.

**패턴 남용**: "디자인 패턴 23개를 모두 사용해야 좋은 코드"가 아닙니다. 필요한 곳에만 적용하세요. 단순한 문제에는 단순한 해법이 최선입니다.

**과도한 추상화**: 추상화 레이어를 너무 많이 만들면 코드를 이해하기 어려워집니다. 실제로 변경되거나 교체될 부분만 추상화하세요.

**성급한 최적화**: 측정하지 않고 최적화하면 오히려 코드를 복잡하게 만듭니다. 프로파일러로 병목을 찾은 후 최적화하세요.

**균형이 핵심입니다.** 컴퓨팅 사고는 도구이지 목적이 아닙니다. 상황에 맞게 유연하게 적용하세요.

### 지속적 개선

컴퓨팅 사고 능력을 향상시키는 방법:

**1. 다양한 프로젝트 경험**  
다양한 도메인, 기술 스택, 팀 규모의 프로젝트를 경험하면서 4대 원리가 어떻게 다르게 적용되는지 관찰하세요.

**2. 오픈소스 분석**  
잘 설계된 오픈소스 프로젝트(React, Vue, Django 등)의 아키텍처를 분석하세요. 어떻게 분해되었는지, 어떤 패턴이 사용되었는지, 어떻게 추상화되었는지를 파악하세요.

**3. 리팩토링 연습**  
기존 코드를 4대 원리를 적용하여 개선하는 연습을 하세요. Before/After를 비교하며 무엇이 나아졌는지 분석하세요.

**4. 설계 리뷰 참여**  
다른 사람의 설계를 리뷰하고, 자신의 설계도 리뷰받으세요. 다양한 관점을 접하면서 사고가 확장됩니다.

**5. 독서와 학습**  
"Clean Architecture", "Domain-Driven Design", "Design Patterns" 같은 고전을 읽으세요. 온라인 강의, 컨퍼런스 발표도 좋은 학습 자원입니다.

**마무리하며**

컴퓨팅 사고는 프로그래밍을 넘어 문제 해결의 보편적 방법론입니다. 소프트웨어 개발뿐만 아니라 비즈니스 문제, 조직 설계, 심지어 일상생활의 문제도 4대 원리로 접근할 수 있습니다. AI 시대에 이 사고방식은 더욱 가치있어졌습니다. AI가 코드를 생성하지만, 어떤 코드를 생성할지 결정하는 것은 여러분의 컴퓨팅 사고입니다.

이번 주 학습한 4대 원리는 앞으로 모든 챕터의 기초가 됩니다. 3주차부터는 이 원리들을 더 복잡한 시나리오에 적용하고, AI와의 협업에서 어떻게 활용하는지 깊이 탐구할 것입니다. 4대 원리를 확실히 내재화하고 다음 주차로 나아가세요.

다음 주차에 다시 만나요!
