# Chapter 13. ìµœì¢… í”„ë¡œì íŠ¸ II - êµ¬í˜„

**ë‚œì´ë„: ğŸ”´ ê³ ê¸‰**

## ê°œìš”

ì„¤ê³„ê°€ ì™„ë£Œë˜ì—ˆìœ¼ë‹ˆ ì´ì œ ì‹¤ì œ êµ¬í˜„ì— ëŒì…í•©ë‹ˆë‹¤. ì´ë²ˆ ì±•í„°ëŠ” GitHub Copilotê³¼ í•¨ê»˜ ì´ì „ ì±•í„°ì—ì„œ ì„¤ê³„í•œ ì‹œìŠ¤í…œì„ ì½”ë“œë¡œ êµ¬í˜„í•˜ëŠ” ì‹œê°„ì…ë‹ˆë‹¤. ëª…í™•í•œ ì„¤ê³„ê°€ ìˆê¸°ì— Copilotì€ ì—¬ëŸ¬ë¶„ì˜ ì˜ë„ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³ , ê³ í’ˆì§ˆ ì½”ë“œë¥¼ ë¹ ë¥´ê²Œ ìƒì„±í•  ê²ƒì…ë‹ˆë‹¤.

ë°”ì´ë¸Œ ì½”ë”©ì˜ ì§„ê°€ê°€ ë°œíœ˜ë˜ëŠ” ìˆœê°„ì…ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì€ "ë¬´ì—‡ì„" ë§Œë“¤ì§€ì— ì§‘ì¤‘í•˜ê³ , Copilotì€ "ì–´ë–»ê²Œ" ë§Œë“¤ì§€ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤. í•˜ì§€ë§Œ Copilotì´ ìƒì„±í•œ ì½”ë“œë¥¼ ë§¹ëª©ì ìœ¼ë¡œ ìˆ˜ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê²€ì¦í•˜ê³ , ê°œì„ í•˜ê³ , í…ŒìŠ¤íŠ¸í•˜ëŠ” ê³¼ì •ì´ ë°˜ë“œì‹œ í•„ìš”í•©ë‹ˆë‹¤.

### í•™ìŠµ ëª©í‘œ

**1. ì²´ê³„ì ì¸ êµ¬í˜„ í”„ë¡œì„¸ìŠ¤**
- Domain â†’ Application â†’ Infrastructure â†’ Presentation ìˆœì„œ
- ë‹¨ê³„ë³„ ê²€ì¦ê³¼ í…ŒìŠ¤íŠ¸
- Git ë¸Œëœì¹˜ ì „ëµê³¼ ì»¤ë°‹ ê´€ë¦¬
- ë°˜ë³µì  ê°œì„  ì›Œí¬í”Œë¡œìš°

**2. ê³ ê¸‰ í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§**
- ë³µì¡í•œ ê¸°ëŠ¥ì„ ëª…í™•íˆ ì „ë‹¬í•˜ëŠ” í”„ë¡¬í”„íŠ¸
- ì»¨í…ìŠ¤íŠ¸ ì œê³µì„ í†µí•œ ì •í™•ë„ í–¥ìƒ
- Agent ëª¨ë“œì˜ íš¨ê³¼ì  í™œìš©
- ë‹¤ì¤‘ íŒŒì¼ í¸ì§‘ ì „ëµ

**3. ì½”ë“œ í’ˆì§ˆ ê´€ë¦¬**
- AI ìƒì„± ì½”ë“œì˜ ë¦¬ë·° ê¸°ë²•
- SOLID ì›ì¹™ ì¤€ìˆ˜ ê²€ì¦
- ì„±ëŠ¥ ë° ë³´ì•ˆ ì²´í¬
- ë¦¬íŒ©í† ë§ ì „ëµ

**4. í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œ (TDD)**
- Copilotê³¼ í•¨ê»˜í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì‘ì„±
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, í†µí•© í…ŒìŠ¤íŠ¸, E2E í…ŒìŠ¤íŠ¸
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ê´€ë¦¬
- CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì¶•

**5. ì‹¤ì „ ë¬¸ì œ í•´ê²°**
- ë””ë²„ê¹…ê³¼ ì—ëŸ¬ í•´ê²°
- ì„±ëŠ¥ ìµœì í™”
- ì˜ˆìƒì¹˜ ëª»í•œ ìš”êµ¬ì‚¬í•­ ëŒ€ì‘
- ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬

ì´ë²ˆ ì£¼ì°¨ë¥¼ ë§ˆì¹˜ë©´ ë³µì¡í•œ í”„ë¡œì íŠ¸ë¥¼ AIì™€ í˜‘ì—…í•˜ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ëŠ¥ë ¥ì„ ê°–ì¶”ê²Œ ë©ë‹ˆë‹¤.

## 1. GitHub Copilotê³¼ í˜‘ì—…í•˜ì—¬ í”„ë¡œì íŠ¸ êµ¬í˜„

Clean Architectureë¥¼ ë”°ë¼ ì•ˆìª½ ë ˆì´ì–´ë¶€í„° ë°”ê¹¥ìª½ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤. ê° ë‹¨ê³„ë§ˆë‹¤ Copilotì„ íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ì „ëµì„ ì‚´í´ë´…ë‹ˆë‹¤.

### 1.1 Domain ë ˆì´ì–´ êµ¬í˜„ (1-2ì¼ì°¨)

**Step 1: ì—”í‹°í‹° êµ¬í˜„**

```typescript
// í”„ë¡¬í”„íŠ¸ ì „ëµ: ëª…í™•í•œ ìš”êµ¬ì‚¬í•­ + ì œì•½ ì¡°ê±´
/*
Task ì—”í‹°í‹°ë¥¼ Domain-Driven Design ì›ì¹™ìœ¼ë¡œ ì‘ì„±í•´ì¤˜:

ìš”êµ¬ì‚¬í•­:
- ë¶ˆë³€ì„± ë³´ì¥ (private constructor, factory method)
- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë©”ì„œë“œ (start, complete, decompose)
- ìƒíƒœ ì „ì´ ê²€ì¦
- ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰

ì œì•½ ì¡°ê±´:
- ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ (ìˆœìˆ˜ TypeScript)
- Value Object ì‚¬ìš© (Priority, TaskStatus)
- ì—”í‹°í‹° ìœ íš¨ì„± ê²€ì¦
*/

// Copilotì´ ìƒì„±í•œ ì½”ë“œ (ì¼ë¶€)
export class Task {
  private constructor(
    private readonly _id: TaskId,
    private _title: TaskTitle,
    private _description: string,
    private _status: TaskStatus,
    private _priority: Priority,
    // ... ê¸°íƒ€ ì†ì„±
  ) {}

  // Factory Method
  static create(props: CreateTaskProps): Result<Task> {
    // ìœ íš¨ì„± ê²€ì¦
    if (props.title.length < 3) {
      return Result.fail('Title must be at least 3 characters');
    }

    const task = new Task(
      TaskId.create(),
      TaskTitle.create(props.title),
      props.description || '',
      TaskStatus.TODO,
      props.priority || Priority.MEDIUM,
      // ...
    );

    // ë„ë©”ì¸ ì´ë²¤íŠ¸
    task.addDomainEvent(new TaskCreatedEvent(task));

    return Result.ok(task);
  }

  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  start(): Result<void> {
    if (this._status !== TaskStatus.TODO) {
      return Result.fail(`Cannot start task in ${this._status} status`);
    }

    this._status = TaskStatus.IN_PROGRESS;
    this.addDomainEvent(new TaskStartedEvent(this));

    return Result.ok();
  }

  complete(): Result<void> {
    if (this._status !== TaskStatus.IN_PROGRESS) {
      return Result.fail(`Cannot complete task in ${this._status} status`);
    }

    // í•˜ìœ„ ì‘ì—… ì™„ë£Œ ì²´í¬
    if (this.hasIncompleteSubTasks()) {
      return Result.fail('All subtasks must be completed first');
    }

    this._status = TaskStatus.DONE;
    this._completedAt = new Date();
    this.addDomainEvent(new TaskCompletedEvent(this));

    return Result.ok();
  }

  // Getter methods
  get id(): TaskId { return this._id; }
  get title(): string { return this._title.value; }
  get status(): TaskStatus { return this._status; }
  // ...
}
```

**ê²€ì¦ í¬ì¸íŠ¸:**
- [ ] ë¶ˆë³€ì„±ì´ ë³´ì¥ë˜ëŠ”ê°€? (private setter, readonly)
- [ ] ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì´ ì—”í‹°í‹° ë‚´ë¶€ì— ìˆëŠ”ê°€?
- [ ] ì™¸ë¶€ ì˜ì¡´ì„±ì´ ì—†ëŠ”ê°€?
- [ ] ë„ë©”ì¸ ì´ë²¤íŠ¸ê°€ ì ì ˆíˆ ë°œìƒí•˜ëŠ”ê°€?

### 1.2 Application ë ˆì´ì–´ êµ¬í˜„ (3-4ì¼ì°¨)

**Step 2: Use Case êµ¬í˜„**

```typescript
// í”„ë¡¬í”„íŠ¸: Agent ëª¨ë“œ í™œìš©
// @workspace /new CreateTaskUseCaseë¥¼ êµ¬í˜„í•´ì¤˜. 
// ITaskRepositoryì™€ IAIServiceë¥¼ ì£¼ì…ë°›ê³ , 
// íŠ¸ëœì­ì…˜ê³¼ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í¬í•¨í•´ì¤˜.

@Injectable()
export class CreateTaskUseCase implements IUseCase<CreateTaskInput, TaskDto> {
  constructor(
    private readonly taskRepository: ITaskRepository,
    private readonly aiService: IAIService,
    private readonly unitOfWork: IUnitOfWork,
    private readonly eventBus: IEventBus
  ) {}

  async execute(input: CreateTaskInput): Promise<Result<TaskDto>> {
    try {
      // 1. ì…ë ¥ ê²€ì¦
      const validationResult = this.validate(input);
      if (validationResult.isFailure) {
        return Result.fail(validationResult.error);
      }

      // 2. ë„ë©”ì¸ ì—”í‹°í‹° ìƒì„±
      const taskOrError = Task.create({
        title: input.title,
        description: input.description,
        priority: input.priority,
        userId: input.userId,
        dueDate: input.dueDate
      });

      if (taskOrError.isFailure) {
        return Result.fail(taskOrError.error);
      }

      const task = taskOrError.getValue();

      // 3. AI ìë™ ë¶„í•´ (ì„ íƒì )
      let subTasks: Task[] = [];
      if (input.autoDecompose) {
        const decompositionResult = await this.aiService.decomposeTask({
          taskDescription: task.title,
          context: task.description
        });

        if (decompositionResult.isSuccess) {
          const suggestions = decompositionResult.getValue();
          subTasks = this.createSubTasks(task, suggestions);
        }
      }

      // 4. íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì €ì¥
      await this.unitOfWork.transaction(async () => {
        await this.taskRepository.save(task);

        if (subTasks.length > 0) {
          await this.taskRepository.saveMany(subTasks);
        }

        // ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰
        await this.eventBus.publishAll(task.domainEvents);
      });

      // 5. DTO ë³€í™˜
      const dto = TaskMapper.toDto(task);
      return Result.ok(dto);

    } catch (error) {
      return Result.fail(`Failed to create task: ${error.message}`);
    }
  }

  private validate(input: CreateTaskInput): Result<void> {
    if (!input.title || input.title.trim().length < 3) {
      return Result.fail('Title must be at least 3 characters');
    }

    if (input.dueDate && input.dueDate < new Date()) {
      return Result.fail('Due date must be in the future');
    }

    return Result.ok();
  }

  private createSubTasks(parent: Task, suggestions: AIDecompositionResult): Task[] {
    return suggestions.subTasks.map((suggestion, index) => {
      const subTaskOrError = Task.create({
        title: suggestion,
        userId: parent.userId,
        parentId: parent.id,
        priority: parent.priority,
        estimatedHours: suggestions.estimatedHours[index]
      });

      return subTaskOrError.getValue();
    });
  }
}
```

**Copilot í™œìš© íŒ:**
- Use CaseëŠ” íŒ¨í„´ì´ ë°˜ë³µë˜ë¯€ë¡œ ì²« ë²ˆì§¸ë¥¼ ì™„ì„±í•˜ë©´ ë‚˜ë¨¸ì§€ëŠ” ë¹ ë¥´ê²Œ ìƒì„± ê°€ëŠ¥
- `// ì´ íŒ¨í„´ìœ¼ë¡œ UpdateTaskUseCaseë„ ë§Œë“¤ì–´ì¤˜` ë¼ëŠ” í”„ë¡¬í”„íŠ¸ë¡œ ì¬í™œìš©

### 1.3 Infrastructure ë ˆì´ì–´ êµ¬í˜„ (5-7ì¼ì°¨)

**Step 3: Repository êµ¬í˜„**

```typescript
// í”„ë¡¬í”„íŠ¸: êµ¬ì²´ì ì¸ ê¸°ìˆ  ìŠ¤íƒ ëª…ì‹œ
/*
PostgresTaskRepositoryë¥¼ TypeORMìœ¼ë¡œ êµ¬í˜„í•´ì¤˜:
- ITaskRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
- N+1 ë¬¸ì œ ë°©ì§€ (eager loading, join)
- íŠ¸ëœì­ì…˜ ì§€ì›
- ì—ëŸ¬ë¥¼ DatabaseExceptionìœ¼ë¡œ ë³€í™˜
- ë³µì¡í•œ ì¿¼ë¦¬ëŠ” QueryBuilder ì‚¬ìš©
*/

@Injectable()
export class PostgresTaskRepository implements ITaskRepository {
  constructor(
    @InjectRepository(TaskEntity)
    private readonly repo: Repository<TaskEntity>,
    private readonly mapper: TaskMapper
  ) {}

  async save(task: Task): Promise<void> {
    try {
      const entity = this.mapper.toPersistence(task);
      await this.repo.save(entity);
    } catch (error) {
      throw new DatabaseException('Failed to save task', error);
    }
  }

  async findById(id: string): Promise<Task | null> {
    try {
      const entity = await this.repo.findOne({
        where: { id },
        relations: ['subTasks', 'assignee'] // Eager loadingìœ¼ë¡œ N+1 ë°©ì§€
      });

      return entity ? this.mapper.toDomain(entity) : null;
    } catch (error) {
      throw new DatabaseException('Failed to find task', error);
    }
  }

  async findByUserId(userId: string, filter?: TaskFilter): Promise<Task[]> {
    try {
      const qb = this.repo
        .createQueryBuilder('task')
        .leftJoinAndSelect('task.subTasks', 'subTasks')
        .leftJoinAndSelect('task.assignee', 'assignee')
        .where('task.userId = :userId', { userId });

      // ë™ì  í•„í„°ë§
      if (filter?.status) {
        qb.andWhere('task.status IN (:...statuses)', { statuses: filter.status });
      }

      if (filter?.priority) {
        qb.andWhere('task.priority IN (:...priorities)', { priorities: filter.priority });
      }

      if (filter?.dueDate) {
        qb.andWhere('task.dueDate <= :dueDate', { dueDate: filter.dueDate });
      }

      // ì •ë ¬
      qb.orderBy('task.priority', 'DESC')
        .addOrderBy('task.dueDate', 'ASC', 'NULLS LAST');

      // í˜ì´ì§€ë„¤ì´ì…˜
      if (filter?.page && filter?.limit) {
        qb.skip((filter.page - 1) * filter.limit).take(filter.limit);
      }

      const entities = await qb.getMany();
      return entities.map(e => this.mapper.toDomain(e));
    } catch (error) {
      throw new DatabaseException('Failed to find tasks', error);
    }
  }

  async findOverdue(): Promise<Task[]> {
    const entities = await this.repo
      .createQueryBuilder('task')
      .where('task.dueDate < :now', { now: new Date() })
      .andWhere('task.status != :done', { done: TaskStatus.DONE })
      .getMany();

    return entities.map(e => this.mapper.toDomain(e));
  }
}
```

**ì„±ëŠ¥ ìµœì í™” ì²´í¬:**
- [ ] N+1 ì¿¼ë¦¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ì¸ë±ìŠ¤ê°€ ì ì ˆíˆ ì‚¬ìš©ë˜ëŠ”ê°€?
- [ ] ë¶ˆí•„ìš”í•œ ë°ì´í„° ë¡œë”©ì€ ì—†ëŠ”ê°€?
- [ ] í˜ì´ì§€ë„¤ì´ì…˜ì´ êµ¬í˜„ë˜ì—ˆëŠ”ê°€?

### 1.4 Presentation ë ˆì´ì–´ êµ¬í˜„ (8-9ì¼ì°¨)

**Step 4: Controller êµ¬í˜„**

```typescript
// Slash ëª…ë ¹ì–´ í™œìš©: /docë¡œ Swagger ë¬¸ì„œ ìë™ ìƒì„±
@ApiTags('Tasks')
@Controller('api/tasks')
@UseGuards(JwtAuthGuard)
export class TaskController {
  constructor(
    private readonly createTaskUseCase: CreateTaskUseCase,
    private readonly updateTaskUseCase: UpdateTaskUseCase,
    private readonly getTasksUseCase: GetTasksUseCase
  ) {}

  @Post()
  @ApiOperation({ summary: 'Create a new task' })
  @ApiResponse({ status: 201, type: TaskResponseDto })
  @ApiResponse({ status: 400, description: 'Validation error' })
  async createTask(
    @Body() dto: CreateTaskDto,
    @CurrentUser() user: UserPayload
  ): Promise<ApiResponse<TaskResponseDto>> {
    const result = await this.createTaskUseCase.execute({
      ...dto,
      userId: user.id
    });

    if (result.isFailure) {
      throw new BadRequestException(result.error);
    }

    return {
      success: true,
      data: result.getValue()
    };
  }

  @Get()
  @ApiOperation({ summary: 'Get user tasks' })
  @ApiQuery({ name: 'status', required: false, enum: TaskStatus, isArray: true })
  @ApiQuery({ name: 'page', required: false, type: Number })
  async getTasks(
    @CurrentUser() user: UserPayload,
    @Query() query: GetTasksQueryDto
  ): Promise<ApiResponse<TaskResponseDto[]>> {
    const result = await this.getTasksUseCase.execute({
      userId: user.id,
      filter: query
    });

    return {
      success: true,
      data: result.getValue(),
      meta: {
        page: query.page || 1,
        limit: query.limit || 20,
        total: result.getValue().length
      }
    };
  }

  @Patch(':id')
  @ApiOperation({ summary: 'Update a task' })
  async updateTask(
    @Param('id') id: string,
    @Body() dto: UpdateTaskDto,
    @CurrentUser() user: UserPayload
  ): Promise<ApiResponse<TaskResponseDto>> {
    const result = await this.updateTaskUseCase.execute({
      id,
      userId: user.id,
      ...dto
    });

    if (result.isFailure) {
      throw new NotFoundException(result.error);
    }

    return {
      success: true,
      data: result.getValue()
    };
  }
}
```

// ì´ë¯¸ì§€ë¡œ êµì²´ë˜ì–´ì•¼ í•¨ : Clean Architecture ë ˆì´ì–´ë³„ êµ¬í˜„ ìˆœì„œ - Domain â†’ Application â†’ Infrastructure â†’ Presentationì˜ íë¦„ì„ í™”ì‚´í‘œë¡œ í‘œì‹œí•œ ë‹¤ì´ì–´ê·¸ë¨
í”„ë¡¬í”„íŠ¸: A layered architecture implementation flow diagram showing 4 horizontal layers stacked from bottom to top: 1) Domain Layer (core icon, pure business logic), 2) Application Layer (use case icon, business rules), 3) Infrastructure Layer (database/API icons, external dependencies), 4) Presentation Layer (controller/UI icons). Large upward arrows on the left showing "Implementation Order" from bottom to top. Each layer has checkmark icons. Blue gradient colors, professional software architecture style, white background.

## 2. ë³µì¡í•œ ê¸°ëŠ¥ êµ¬í˜„ê³¼ í”„ë¡¬í”„íŠ¸ ìµœì í™”

AI ê¸°ë°˜ ì‘ì—… ë¶„í•´ ê¸°ëŠ¥ì²˜ëŸ¼ ë³µì¡í•œ ë¡œì§ì€ í”„ë¡¬í”„íŠ¸ë¥¼ ì–´ë–»ê²Œ ì‘ì„±í•˜ëŠëƒê°€ ê²°ê³¼ì˜ í’ˆì§ˆì„ ê²°ì •í•©ë‹ˆë‹¤.

### 2.1 AI ì„œë¹„ìŠ¤ í†µí•©

**ê³ ê¸‰ í”„ë¡¬í”„íŠ¸ ê¸°ë²•:**

```typescript
// í”„ë¡¬í”„íŠ¸: ë©€í‹°í„´ ëŒ€í™”ë¡œ ì ì§„ì  ê°œì„ 
// 1ì°¨: ê¸°ë³¸ êµ¬ì¡° ìƒì„±
// "OpenAI APIë¥¼ ì‚¬ìš©í•˜ëŠ” TaskDecompositionServiceë¥¼ ë§Œë“¤ì–´ì¤˜"

// 2ì°¨: í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ì¶”ê°€
// "ì‘ì—… ë¶„í•´ í”„ë¡¬í”„íŠ¸ë¥¼ ê°œì„ í•´ì¤˜. ì»´í“¨íŒ… ì‚¬ê³  ì›ì¹™(ë¶„í•´, íŒ¨í„´, ì¶”ìƒí™”)ì„ ì ìš©í•˜ë„ë¡"

// 3ì°¨: ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”
// "API ì‹¤íŒ¨, íƒ€ì„ì•„ì›ƒ, ë¶€ì ì ˆí•œ ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ ì¶”ê°€í•´ì¤˜"

@Injectable()
export class TaskDecompositionService implements IAIService {
  constructor(
    private readonly openai: OpenAIApi,
    private readonly config: ConfigService
  ) {}

  async decomposeTask(input: DecomposeTaskInput): Promise<Result<AIDecompositionResult>> {
    try {
      // ì²´ê³„ì ì¸ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
      const systemPrompt = this.buildSystemPrompt();
      const userPrompt = this.buildUserPrompt(input);

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        response_format: { type: 'json_object' },
        temperature: 0.7,
        max_tokens: 1000
      });

      const result = JSON.parse(response.choices[0].message.content);

      // ê²°ê³¼ ê²€ì¦
      if (!this.validateResponse(result)) {
        return Result.fail('Invalid AI response format');
      }

      return Result.ok({
        subTasks: result.subTasks,
        estimatedHours: result.estimatedHours,
        reasoning: result.reasoning,
        confidence: result.confidence
      });

    } catch (error) {
      if (error.code === 'rate_limit_exceeded') {
        return Result.fail('AI service rate limit exceeded. Please try again later.');
      }
      return Result.fail(`AI service error: ${error.message}`);
    }
  }

  private buildSystemPrompt(): string {
    return `
ë‹¹ì‹ ì€ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ì‘ì—…ì„ êµ¬í˜„ ê°€ëŠ¥í•œ ë‹¨ìœ„ë¡œ ë¶„í•´í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì»´í“¨íŒ… ì‚¬ê³  ì›ì¹™ì„ ì ìš©í•˜ì„¸ìš”:
1. ë¶„í•´ (Decomposition): í° ì‘ì—…ì„ 4-8ì‹œê°„ ë‚´ ì™„ë£Œ ê°€ëŠ¥í•œ ì‘ì€ ì‘ì—…ìœ¼ë¡œ
2. íŒ¨í„´ ì¸ì‹ (Pattern Recognition): ìœ ì‚¬í•œ ì‘ì—… íŒ¨í„´ í™œìš©
3. ì¶”ìƒí™” (Abstraction): êµ¬ì²´ì ì´ì§€ë§Œ êµ¬í˜„ ë°©ë²•ì€ ì—´ì–´ë‘ê¸°
4. ì•Œê³ ë¦¬ì¦˜ì  ì‚¬ê³ : ì˜ì¡´ì„±ê³¼ ìˆœì„œ ê³ ë ¤

ì‘ë‹µ í˜•ì‹ (JSON):
{
  "subTasks": ["ì‘ì—…1", "ì‘ì—…2", ...],
  "estimatedHours": [4, 6, ...],
  "reasoning": "ë¶„í•´ ê·¼ê±°",
  "confidence": 0.85
}
    `.trim();
  }

  private buildUserPrompt(input: DecomposeTaskInput): string {
    return `
ë‹¤ìŒ ì‘ì—…ì„ ë¶„í•´í•´ì£¼ì„¸ìš”:

ì‘ì—… ì œëª©: ${input.taskDescription}
${input.context ? `ì»¨í…ìŠ¤íŠ¸: ${input.context}` : ''}
${input.technicalStack ? `ê¸°ìˆ  ìŠ¤íƒ: ${input.technicalStack.join(', ')}` : ''}
${input.constraints ? `ì œì•½ ì¡°ê±´: ${input.constraints}` : ''}

ê° í•˜ìœ„ ì‘ì—…ì€:
- ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤
- ëª…í™•í•œ ì™„ë£Œ ê¸°ì¤€ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- ì˜ì¡´ì„±ì´ ìˆë‹¤ë©´ ìˆœì„œë¥¼ ê³ ë ¤í•´ì£¼ì„¸ìš”
    `.trim();
  }

  private validateResponse(response: any): boolean {
    return (
      Array.isArray(response.subTasks) &&
      Array.isArray(response.estimatedHours) &&
      response.subTasks.length === response.estimatedHours.length &&
      typeof response.reasoning === 'string' &&
      typeof response.confidence === 'number'
    );
  }
}
```

### 2.2 ì‹¤ì‹œê°„ í˜‘ì—… ê¸°ëŠ¥ (WebSocket)

```typescript
// Agent ëª¨ë“œ: ë³µì¡í•œ WebSocket Gateway ìƒì„±
// @workspace /new TaskEventGatewayë¥¼ ë§Œë“¤ì–´ì¤˜. 
// ì‹¤ì‹œê°„ ì‘ì—… ë™ê¸°í™”, ì‚¬ìš©ì ì¸ì¦, ë£¸ ê´€ë¦¬ë¥¼ í¬í•¨í•´ì¤˜.

@WebSocketGateway({
  cors: { origin: '*' },
  namespace: 'tasks'
})
export class TaskEventGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private userRooms = new Map<string, Set<string>>(); // userId -> Set of roomIds

  constructor(
    private readonly jwtService: JwtService
  ) {}

  async handleConnection(client: Socket) {
    try {
      // ì¸ì¦
      const token = client.handshake.auth.token;
      const payload = await this.jwtService.verifyAsync(token);

      client.data.userId = payload.sub;
      client.data.user = payload;

      // ì‚¬ìš©ì ë°©ì— ì°¸ê°€
      const userRoom = `user:${payload.sub}`;
      client.join(userRoom);

      this.userRooms.set(payload.sub, new Set([userRoom]));

      console.log(`User ${payload.sub} connected`);
    } catch (error) {
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    const userId = client.data.userId;
    if (userId) {
      this.userRooms.delete(userId);
      console.log(`User ${userId} disconnected`);
    }
  }

  @SubscribeMessage('joinProject')
  handleJoinProject(
    @MessageBody() data: { projectId: string },
    @ConnectedSocket() client: Socket
  ) {
    const projectRoom = `project:${data.projectId}`;
    client.join(projectRoom);

    const userId = client.data.userId;
    const rooms = this.userRooms.get(userId) || new Set();
    rooms.add(projectRoom);
    this.userRooms.set(userId, rooms);

    return { success: true, room: projectRoom };
  }

  // ì‘ì—… ìƒì„± ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
  notifyTaskCreated(task: Task) {
    const userRoom = `user:${task.userId}`;
    this.server.to(userRoom).emit('task.created', {
      task: TaskMapper.toDto(task),
      timestamp: new Date()
    });
  }

  // ì‘ì—… ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸
  notifyTaskUpdated(task: Task) {
    const userRoom = `user:${task.userId}`;
    this.server.to(userRoom).emit('task.updated', {
      task: TaskMapper.toDto(task),
      timestamp: new Date()
    });
  }
}
```

## 3. ì½”ë“œ í’ˆì§ˆ ê´€ë¦¬ ë° ë¦¬ë·°

AIê°€ ìƒì„±í•œ ì½”ë“œë„ ë°˜ë“œì‹œ ë¦¬ë·°ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì²´ê³„ì ì¸ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆ˜ë¦½í•©ë‹ˆë‹¤.

### 3.1 ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
# PR ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

## Architecture
- [ ] Clean Architecture ë ˆì´ì–´ë¥¼ ì¤€ìˆ˜í•˜ëŠ”ê°€?
- [ ] ì˜ì¡´ì„± ë°©í–¥ì´ ì˜¬ë°”ë¥¸ê°€? (â†’ Domain)
- [ ] ë„ë©”ì¸ ë¡œì§ì´ Domain ë ˆì´ì–´ì— ìˆëŠ”ê°€?

## SOLID ì›ì¹™
- [ ] SRP: í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§€ëŠ”ê°€?
- [ ] OCP: í™•ì¥ì— ì—´ë ¤ìˆê³  ìˆ˜ì •ì— ë‹«í˜€ìˆëŠ”ê°€?
- [ ] LSP: í•˜ìœ„ íƒ€ì…ì´ ìƒìœ„ íƒ€ì…ì„ ëŒ€ì²´ ê°€ëŠ¥í•œê°€?
- [ ] ISP: ì¸í„°í˜ì´ìŠ¤ê°€ ì‘ê³  êµ¬ì²´ì ì¸ê°€?
- [ ] DIP: êµ¬ì²´ í´ë˜ìŠ¤ê°€ ì•„ë‹Œ ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ëŠ”ê°€?

## ì„±ëŠ¥
- [ ] N+1 ì¿¼ë¦¬ ë¬¸ì œê°€ ì—†ëŠ”ê°€?
- [ ] ë¶ˆí•„ìš”í•œ ë°˜ë³µë¬¸ì´ ì—†ëŠ”ê°€?
- [ ] ìºì‹±ì´ ì ì ˆíˆ ì ìš©ë˜ì—ˆëŠ”ê°€?

## ë³´ì•ˆ
- [ ] ì…ë ¥ ê²€ì¦ì´ ì¶©ë¶„í•œê°€?
- [ ] SQL Injection ì·¨ì•½ì ì´ ì—†ëŠ”ê°€?
- [ ] ì¸ì¦/ì¸ê°€ê°€ ì ì ˆí•œê°€?
- [ ] ë¯¼ê° ì •ë³´ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ê°€?

## í…ŒìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ê°€ 80% ì´ìƒì¸ê°€?
- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ê°€ í…ŒìŠ¤íŠ¸ë˜ì—ˆëŠ”ê°€?

## ì½”ë“œ í’ˆì§ˆ
- [ ] ë³€ìˆ˜/í•¨ìˆ˜ëª…ì´ ëª…í™•í•œê°€?
- [ ] ë§¤ì§ ë„˜ë²„ê°€ ì—†ëŠ”ê°€?
- [ ] ì£¼ì„ì´ í•„ìš”í•œ ë³µì¡í•œ ë¡œì§ì€ ì„¤ëª…ë˜ì—ˆëŠ”ê°€?
- [ ] ì¤‘ë³µ ì½”ë“œê°€ ì—†ëŠ”ê°€?
```

### 3.2 ìë™í™”ëœ ì½”ë“œ í’ˆì§ˆ ê²€ì¦

```json
// package.json - í’ˆì§ˆ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸
{
  "scripts": {
    "lint": "eslint . --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "type-check": "tsc --noEmit",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "quality": "npm run lint && npm run type-check && npm run test",
    "pre-commit": "lint-staged"
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write",
      "jest --findRelatedTests"
    ]
  }
}
```

```yaml
# .github/workflows/quality-check.yml
name: Code Quality Check

on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Test
        run: npm run test
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

## 4. í…ŒìŠ¤íŠ¸ ì „ëµ ë° ìë™í™”

Copilotì„ í™œìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ì„±í•©ë‹ˆë‹¤.

### 4.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```typescript
// Slash ëª…ë ¹ì–´: /tests CreateTaskUseCaseì˜ í…ŒìŠ¤íŠ¸ ì‘ì„±í•´ì¤˜

describe('CreateTaskUseCase', () => {
  let useCase: CreateTaskUseCase;
  let mockTaskRepository: jest.Mocked<ITaskRepository>;
  let mockAIService: jest.Mocked<IAIService>;
  let mockUnitOfWork: jest.Mocked<IUnitOfWork>;
  let mockEventBus: jest.Mocked<IEventBus>;

  beforeEach(() => {
    mockTaskRepository = {
      save: jest.fn(),
      saveMany: jest.fn(),
      findById: jest.fn()
    } as any;

    mockAIService = {
      decomposeTask: jest.fn()
    } as any;

    mockUnitOfWork = {
      transaction: jest.fn((work) => work())
    } as any;

    mockEventBus = {
      publishAll: jest.fn()
    } as any;

    useCase = new CreateTaskUseCase(
      mockTaskRepository,
      mockAIService,
      mockUnitOfWork,
      mockEventBus
    );
  });

  describe('execute', () => {
    it('should_create_task_successfully', async () => {
      // Arrange
      const input: CreateTaskInput = {
        title: 'Implement authentication',
        description: 'JWT-based auth',
        priority: Priority.HIGH,
        userId: 'user-123',
        autoDecompose: false
      };

      // Act
      const result = await useCase.execute(input);

      // Assert
      expect(result.isSuccess).toBe(true);
      expect(mockTaskRepository.save).toHaveBeenCalledTimes(1);
      expect(mockUnitOfWork.transaction).toHaveBeenCalledTimes(1);
    });

    it('should_fail_with_invalid_title', async () => {
      // Arrange
      const input: CreateTaskInput = {
        title: 'ab', // ë„ˆë¬´ ì§§ìŒ
        userId: 'user-123'
      };

      // Act
      const result = await useCase.execute(input);

      // Assert
      expect(result.isFailure).toBe(true);
      expect(result.error).toContain('at least 3 characters');
      expect(mockTaskRepository.save).not.toHaveBeenCalled();
    });

    it('should_decompose_task_when_autoDecompose_is_true', async () => {
      // Arrange
      const input: CreateTaskInput = {
        title: 'Build REST API',
        userId: 'user-123',
        autoDecompose: true
      };

      mockAIService.decomposeTask.mockResolvedValue(
        Result.ok({
          subTasks: ['Design endpoints', 'Implement controllers', 'Write tests'],
          estimatedHours: [2, 4, 2],
          reasoning: 'Standard API development',
          confidence: 0.9
        })
      );

      // Act
      const result = await useCase.execute(input);

      // Assert
      expect(result.isSuccess).toBe(true);
      expect(mockAIService.decomposeTask).toHaveBeenCalledTimes(1);
      expect(mockTaskRepository.saveMany).toHaveBeenCalledWith(
        expect.arrayContaining([
          expect.objectContaining({ title: expect.any(String) })
        ])
      );
    });

    it('should_rollback_on_repository_error', async () => {
      // Arrange
      const input: CreateTaskInput = {
        title: 'Test task',
        userId: 'user-123'
      };

      mockTaskRepository.save.mockRejectedValue(new Error('DB error'));

      // Act
      const result = await useCase.execute(input);

      // Assert
      expect(result.isFailure).toBe(true);
      expect(result.error).toContain('Failed to create task');
    });
  });
});
```

### 4.2 í†µí•© í…ŒìŠ¤íŠ¸

```typescript
// E2E í…ŒìŠ¤íŠ¸: API ì—”ë“œí¬ì¸íŠ¸ ì „ì²´ í”Œë¡œìš°
describe('Task API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule]
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ë¡œê·¸ì¸
    const loginResponse = await request(app.getHttpServer())
      .post('/api/auth/login')
      .send({ email: 'test@example.com', password: 'password' });

    authToken = loginResponse.body.data.accessToken;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('POST /api/tasks', () => {
    it('should_create_task_and_return_201', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/tasks')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          title: 'Write documentation',
          description: 'API documentation',
          priority: 'HIGH'
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.title).toBe('Write documentation');
    });

    it('should_return_400_for_invalid_input', async () => {
      await request(app.getHttpServer())
        .post('/api/tasks')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          title: 'ab' // ë„ˆë¬´ ì§§ìŒ
        })
        .expect(400);
    });

    it('should_return_401_without_auth_token', async () => {
      await request(app.getHttpServer())
        .post('/api/tasks')
        .send({
          title: 'Unauthorized task'
        })
        .expect(401);
    });
  });
});
```

## 5. ë°˜ë³µì  ê°œì„  ë° í”¼ë“œë°±

êµ¬í˜„ì€ í•œ ë²ˆì— ì™„ì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì§€ì†ì ì¸ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.

### 5.1 ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ë° ìµœì í™”

```typescript
// í”„ë¡¬í”„íŠ¸: "ì´ ì¿¼ë¦¬ì˜ ì„±ëŠ¥ì„ ê°œì„ í•´ì¤˜"
// Before: N+1 ì¿¼ë¦¬ ë¬¸ì œ
async findTasksWithSubTasks(userId: string): Promise<Task[]> {
  const tasks = await this.repo.find({ where: { userId } });

  for (const task of tasks) {
    // N+1 ë¬¸ì œ!
    task.subTasks = await this.repo.find({ where: { parentId: task.id } });
  }

  return tasks;
}

// After: ë‹¨ì¼ ì¿¼ë¦¬ë¡œ ìµœì í™”
async findTasksWithSubTasks(userId: string): Promise<Task[]> {
  const tasks = await this.repo
    .createQueryBuilder('task')
    .leftJoinAndSelect('task.subTasks', 'subTasks')
    .where('task.userId = :userId', { userId })
    .orderBy('task.createdAt', 'DESC')
    .addOrderBy('subTasks.order', 'ASC')
    .getMany();

  return tasks.map(e => this.mapper.toDomain(e));
}
```

### 5.2 ë¦¬íŒ©í† ë§

```typescript
// Copilotì„ í™œìš©í•œ ë¦¬íŒ©í† ë§
// /simplify ì´ í•¨ìˆ˜ë¥¼ ë” ê°„ê²°í•˜ê²Œ ë¦¬íŒ©í† ë§í•´ì¤˜

// Before: ì¤‘ë³µ ì½”ë“œì™€ ë³µì¡í•œ ì¡°ê±´
if (task.status === TaskStatus.TODO) {
  task.status = TaskStatus.IN_PROGRESS;
  task.startedAt = new Date();
  await this.repository.save(task);
  await this.eventBus.publish(new TaskStartedEvent(task));
} else if (task.status === TaskStatus.IN_PROGRESS) {
  if (task.subTasks.every(s => s.status === TaskStatus.DONE)) {
    task.status = TaskStatus.DONE;
    task.completedAt = new Date();
    await this.repository.save(task);
    await this.eventBus.publish(new TaskCompletedEvent(task));
  } else {
    throw new Error('Cannot complete task with incomplete subtasks');
  }
}

// After: ì „ëµ íŒ¨í„´ + ë„ë©”ì¸ ë¡œì§ ë¶„ë¦¬
class TaskStateMachine {
  private transitions: Map<TaskStatus, TransitionStrategy>;

  constructor(private eventBus: IEventBus) {
    this.transitions = new Map([
      [TaskStatus.TODO, new StartTaskStrategy(eventBus)],
      [TaskStatus.IN_PROGRESS, new CompleteTaskStrategy(eventBus)]
    ]);
  }

  async transition(task: Task, to: TaskStatus): Promise<Result<Task>> {
    const strategy = this.transitions.get(task.status);
    if (!strategy) {
      return Result.fail(`No transition available from ${task.status}`);
    }

    return await strategy.execute(task, to);
  }
}
```

### 5.3 ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬

```markdown
# ê¸°ìˆ  ë¶€ì±„ íŠ¸ë˜í‚¹ (technical-debt.md)

## High Priority
- [ ] TaskRepositoryì— ìºì‹± ë ˆì´ì–´ ì¶”ê°€ (ì„±ëŠ¥ ê°œì„  30% ì˜ˆìƒ)
- [ ] AI ì„œë¹„ìŠ¤ ì¬ì‹œë„ ë¡œì§ êµ¬í˜„ (ì•ˆì •ì„±)
- [ ] WebSocket ì—°ê²° í’€ ê´€ë¦¬ (í™•ì¥ì„±)

## Medium Priority
- [ ] ì—ëŸ¬ ë©”ì‹œì§€ ë‹¤êµ­ì–´ ì§€ì›
- [ ] ë¡œê¹… êµ¬ì¡°í™” ë° ì§‘ê³„
- [ ] API ì‘ë‹µ ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

## Low Priority
- [ ] ì½”ë“œ ì£¼ì„ ë³´ì™„
- [ ] íƒ€ì… ì •ì˜ ê°œì„ 
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 90% ë‹¬ì„±
```

// ì´ë¯¸ì§€ë¡œ êµì²´ë˜ì–´ì•¼ í•¨ : ë°˜ë³µì  ê°œì„  ì‚¬ì´í´ - êµ¬í˜„ â†’ í…ŒìŠ¤íŠ¸ â†’ ë¦¬ë·° â†’ ë¦¬íŒ©í† ë§ â†’ ë°°í¬ì˜ ìˆœí™˜ êµ¬ì¡°ë¥¼ ë³´ì—¬ì£¼ëŠ” ë‹¤ì´ì–´ê·¸ë¨
í”„ë¡¬í”„íŠ¸: A circular iterative improvement cycle diagram showing 5 stages connected by curved arrows in clockwise direction: 1) Implementation (coding icon), 2) Testing (test tube with checkmark), 3) Review (magnifying glass), 4) Refactoring (refresh/optimization icon), 5) Deploy (rocket launch). Center shows "Continuous Improvement" text. Each stage has small progress indicators. Green and blue gradient colors, agile development style, white background.

## ì‹¤ìŠµ ê²°ê³¼ ìš”ì•½

13ì£¼ì°¨ì—ì„œ ìš°ë¦¬ëŠ” ì„¤ê³„ë¥¼ ì½”ë“œë¡œ êµ¬í˜„í•˜ëŠ” ì „ ê³¼ì •ì„ ê²½í—˜í–ˆìŠµë‹ˆë‹¤. GitHub Copilotê³¼ í•¨ê»˜ ë³µì¡í•œ ì‹œìŠ¤í…œì„ ë¹ ë¥´ê³  ì •í™•í•˜ê²Œ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤.

### í•µì‹¬ í•™ìŠµ ë‚´ìš©

**1. ì²´ê³„ì ì¸ êµ¬í˜„ í”„ë¡œì„¸ìŠ¤**
- Clean Architecture ë ˆì´ì–´ë³„ êµ¬í˜„ ìˆœì„œ
  - Domain: ìˆœìˆ˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ
  - Application: Use Caseì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
  - Infrastructure: êµ¬ì²´ì  ê¸°ìˆ  êµ¬í˜„ (DB, API)
  - Presentation: Controllerì™€ API ì—”ë“œí¬ì¸íŠ¸
- ê° ë‹¨ê³„ë§ˆë‹¤ í…ŒìŠ¤íŠ¸ì™€ ê²€ì¦ ìˆ˜í–‰
- Git ë¸Œëœì¹˜ ì „ëµê³¼ ì²´ê³„ì  ì»¤ë°‹

**2. ê³ ê¸‰ í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§**
- ëª…í™•í•œ ìš”êµ¬ì‚¬í•­ + ì œì•½ ì¡°ê±´ ì œì‹œ
- ë©€í‹°í„´ ëŒ€í™”ë¡œ ì ì§„ì  ê°œì„ 
- Agent ëª¨ë“œ í™œìš© (`@workspace /new`)
- Slash ëª…ë ¹ì–´ í™œìš© (`/tests`, `/fix`, `/simplify`, `/doc`)
- ì»¨í…ìŠ¤íŠ¸ ì œê³µì„ í†µí•œ ì •í™•ë„ í–¥ìƒ
- ì˜ˆì‹œ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸ë¡œ íŒ¨í„´ ì¬í™œìš©

**3. ë³µì¡í•œ ê¸°ëŠ¥ êµ¬í˜„**
- AI ì„œë¹„ìŠ¤ í†µí•© (OpenAI API)
  - ì²´ê³„ì ì¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
  - ì‘ë‹µ ê²€ì¦ ë° ì—ëŸ¬ ì²˜ë¦¬
  - Rate limit ë° íƒ€ì„ì•„ì›ƒ ê´€ë¦¬
- ì‹¤ì‹œê°„ í˜‘ì—… (WebSocket)
  - ì¸ì¦ ë° ë£¸ ê´€ë¦¬
  - ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
  - ì—°ê²° ê´€ë¦¬ ë° ëª¨ë‹ˆí„°ë§

**4. ì½”ë“œ í’ˆì§ˆ ê´€ë¦¬**
- AI ìƒì„± ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸
  - Architecture: Clean Architecture ì¤€ìˆ˜
  - SOLID ì›ì¹™ ê²€ì¦
  - ì„±ëŠ¥: N+1 ì¿¼ë¦¬, ìºì‹±
  - ë³´ì•ˆ: ì…ë ¥ ê²€ì¦, SQL Injection ë°©ì§€
  - í…ŒìŠ¤íŠ¸: ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ
- ìë™í™”ëœ í’ˆì§ˆ ê²€ì¦
  - ESLint, Prettier, TypeScript
  - Pre-commit hooks (lint-staged)
  - CI/CD íŒŒì´í”„ë¼ì¸ (GitHub Actions)
  - ì½”ë“œ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸

**5. í…ŒìŠ¤íŠ¸ ì „ëµ**
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸: Use Case, Service, Repository í…ŒìŠ¤íŠ¸
  - Mockingì„ í†µí•œ ì˜ì¡´ì„± ê²©ë¦¬
  - ì—£ì§€ ì¼€ì´ìŠ¤ ì»¤ë²„
  - AAA íŒ¨í„´ (Arrange-Act-Assert)
- í†µí•© í…ŒìŠ¤íŠ¸: API E2E í…ŒìŠ¤íŠ¸
  - ì‹¤ì œ í™˜ê²½ì—ì„œ ì „ì²´ í”Œë¡œìš° ê²€ì¦
  - ì¸ì¦/ì¸ê°€ í…ŒìŠ¤íŠ¸
  - ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- Copilotì„ í™œìš©í•œ í…ŒìŠ¤íŠ¸ ìë™ ìƒì„±

**6. ë°˜ë³µì  ê°œì„ **
- ì„±ëŠ¥ ìµœì í™”
  - N+1 ì¿¼ë¦¬ í•´ê²° (eager loading, join)
  - ìºì‹± ì „ëµ
  - ì¸ë±ìŠ¤ ìµœì í™”
- ë¦¬íŒ©í† ë§
  - ì¤‘ë³µ ì½”ë“œ ì œê±°
  - ì „ëµ íŒ¨í„´ ì ìš©
  - ë³µì¡ë„ ê°ì†Œ
- ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬
  - ìš°ì„ ìˆœìœ„ë³„ íŠ¸ë˜í‚¹
  - ì ì§„ì  ê°œì„  ê³„íš

### êµ¬í˜„ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

13ì£¼ì°¨ë¥¼ ë§ˆì¹˜ë©´ì„œ ë‹¤ìŒ í•­ëª©ë“¤ì„ ì²´í¬í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤:

**ë„ë©”ì¸ ë ˆì´ì–´**
- [ ] ì—”í‹°í‹°ì™€ Value Object êµ¬í˜„
- [ ] ë„ë©”ì¸ ë¡œì§ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
- [ ] ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰
- [ ] ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ ê²€ì¦

**ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆì´ì–´**
- [ ] ëª¨ë“  Use Case êµ¬í˜„
- [ ] ì…ë ¥ ê²€ì¦ ë° ì—ëŸ¬ ì²˜ë¦¬
- [ ] íŠ¸ëœì­ì…˜ ê´€ë¦¬
- [ ] ë„ë©”ì¸ ì´ë²¤íŠ¸ êµ¬ë…

**ì¸í”„ë¼ìŠ¤íŠ¸ëŸ­ì²˜ ë ˆì´ì–´**
- [ ] Repository êµ¬í˜„ (PostgreSQL + TypeORM)
- [ ] AI ì„œë¹„ìŠ¤ í†µí•© (OpenAI API)
- [ ] ìºì‹± ë ˆì´ì–´ (Redis)
- [ ] ì™¸ë¶€ API í†µí•©

**í”„ë ˆì  í…Œì´ì…˜ ë ˆì´ì–´**
- [ ] RESTful API ì—”ë“œí¬ì¸íŠ¸
- [ ] WebSocket ì‹¤ì‹œê°„ í†µì‹ 
- [ ] ì¸ì¦/ì¸ê°€ ë¯¸ë“¤ì›¨ì–´
- [ ] Swagger API ë¬¸ì„œ

**í’ˆì§ˆ ë° í…ŒìŠ¤íŠ¸**
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (ì»¤ë²„ë¦¬ì§€ 80%+)
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ (E2E)
- [ ] ì½”ë“œ ë¦¬ë·° ì™„ë£Œ
- [ ] CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì¶•

**ë°°í¬ ì¤€ë¹„**
- [ ] í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (.env)
- [ ] Docker ì»¨í…Œì´ë„ˆí™” (ì„ íƒ)
- [ ] ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§
- [ ] ì—ëŸ¬ íŠ¸ë˜í‚¹ (Sentry ë“±)

### Copilot í™œìš© ì„±ê³¼

ì´ë²ˆ ì£¼ì°¨ì—ì„œ GitHub Copilotì„ íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•œ ê²°ê³¼:

**ê°œë°œ ì†ë„:**
- ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ìƒì„± ì‹œê°„: 80% ë‹¨ì¶•
- Repository êµ¬í˜„: 30ë¶„ â†’ 5ë¶„
- í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±: 50% ì‹œê°„ ì ˆì•½

**ì½”ë“œ í’ˆì§ˆ:**
- TypeScript íƒ€ì… ì•ˆì •ì„± í–¥ìƒ
- ì—ëŸ¬ ì²˜ë¦¬ ëˆ„ë½ ê°ì†Œ
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ í–¥ìƒ

**í•™ìŠµ íš¨ê³¼:**
- Clean Architecture íŒ¨í„´ ì´í•´ ì‹¬í™”
- í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ê¸°ìˆ  í–¥ìƒ
- AI í˜‘ì—… ì›Œí¬í”Œë¡œìš° ì²´ë“

### ì‹¤ì „ íŒ: Copilotê³¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¼í•˜ê¸°

**DO (ê¶Œì¥ì‚¬í•­):**
- âœ… ëª…í™•í•œ ì½”ë”© ì»¨ë²¤ì…˜ ë¬¸ì„œí™” (.github/copilot-instructions.md)
- âœ… ì˜ˆì‹œ ì½”ë“œë¥¼ ì œê³µí•˜ì—¬ íŒ¨í„´ í•™ìŠµì‹œí‚¤ê¸°
- âœ… ìƒì„±ëœ ì½”ë“œë¥¼ ë‹¨ê³„ë³„ë¡œ ê²€ì¦
- âœ… ë³µì¡í•œ ê¸°ëŠ¥ì€ ì‘ì€ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ ìš”ì²­
- âœ… Agent ëª¨ë“œë¡œ ì—°ê´€ íŒŒì¼ í•¨ê»˜ ìƒì„±
- âœ… í…ŒìŠ¤íŠ¸ ì½”ë“œë„ Copilotìœ¼ë¡œ ì‘ì„±

**DON'T (ì£¼ì˜ì‚¬í•­):**
- âŒ ìƒì„±ëœ ì½”ë“œë¥¼ ë¦¬ë·° ì—†ì´ ì»¤ë°‹
- âŒ ëª¨í˜¸í•œ í”„ë¡¬í”„íŠ¸ë¡œ ì—¬ëŸ¬ ë²ˆ ì¬ì‹œë„
- âŒ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ Copilotì—ê²Œ ì „ì ìœ¼ë¡œ ì˜ì¡´
- âŒ ë³´ì•ˆ ê´€ë ¨ ì½”ë“œë¥¼ ê²€ì¦ ì—†ì´ ì‚¬ìš©
- âŒ ì„±ëŠ¥ ìµœì í™”ë¥¼ Copilotì—ê²Œë§Œ ë§¡ê¸°ê¸°

### ë‹¤ìŒ ì£¼ ì˜ˆê³ : ìµœì¢… í”„ë¡œì íŠ¸ ë°œí‘œ ë° í”¼ë“œë°±

14ì£¼ì°¨ì—ì„œëŠ” êµ¬í˜„í•œ í”„ë¡œì íŠ¸ë¥¼ ë°œí‘œí•˜ê³  í”¼ë“œë°±ì„ ë°›ìŠµë‹ˆë‹¤:
- í”„ë¡œì íŠ¸ ì‹œì—° ì¤€ë¹„
- ê¸°ìˆ  ë°œí‘œ ìë£Œ ì‘ì„±
- ì•„í‚¤í…ì²˜ ì„¤ëª… ë° ì˜ì‚¬ê²°ì • ê³µìœ 
- ë™ë£Œ í”¼ë“œë°± ë° ê°œì„ ì  ë„ì¶œ
- ë°”ì´ë¸Œ ì½”ë”© ì—¬ì • íšŒê³ 

ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ëª¨ë“  ê²ƒì„ ì¢…í•©í•˜ì—¬ ì™„ì„±ëœ ì‹œìŠ¤í…œì„ ì„ ë³´ì´ëŠ” ì‹œê°„ì…ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ ì„±ì¥ì„ í™•ì¸í•˜ê³  ì¶•í•˜í•˜ëŠ” ìë¦¬ê°€ ë  ê²ƒì…ë‹ˆë‹¤.

êµ¬í˜„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì€ ì´ì œ AIì™€ í•¨ê»˜ ë³µì¡í•œ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
